<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>RBAC权限模型 - 基于角色的访问控制</title>
    <url>/2022/02212221/</url>
    <content><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><!-- TODO:实现搜索框的按键展示(使用页面缩放?或者是弹性相应和直接style) -->

<div class="post-mindmap">
  <iframe class="mindmap" id="mindmap" src="RBAC权限模型 - 基于角色的访问控制.html"></iframe>
  <div class="r">
  <span class="iconfont icon-close"></span>
    <div class="tip"></div>
    <a class="fullscreen-button">Full Screen</a>
</div>
</div>
  <script type="text/javascript">
    var sonWidth = document.getElementById("mindmap").offsetWidth;
    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";
</script>



<h1 id="RABC"><strong>RABC</strong><a class="post-anchor" href="#RABC"></a></h1><h2 id="概述">概述<a class="post-anchor" href="#概述"></a></h2><p>权限管理模型</p>
<h3 id="RBAC（Role-Based-Access-Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。">RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。<a class="post-anchor" href="#RBAC（Role-Based-Access-Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。"></a></h3><hr>
<p>RBAC是一套成熟的权限模型。在传统权限模型中，我们直接把权限赋予用户。<br>而在RBAC中，增加了“角色”的概念，我们首先把权限赋予角色，再把角色赋予用户。这样，由于增加了角色，授权会更加灵活方便。</p>
<p>在RBAC中，根据权限的复杂程度，又可分为RBAC0、RBAC1、RBAC2、RBAC3。<br>其中，RBAC0是基础，RBAC1、RBAC2、RBAC3都是以RBAC0为基础的升级。我们可以根据自家产品权限的复杂程度，选取适合的权限模型。</p>
<h3 id="RBAC-认为授权实际上是Who-、What-、How-三元组之间的关系，也就是Who-对What-进行How-的操作，也就是“主体”对“客体”的操作。">RBAC  认为授权实际上是Who 、What 、How 三元组之间的关系，也就是Who 对What 进行How 的操作，也就是“主体”对“客体”的操作。<a class="post-anchor" href="#RBAC-认为授权实际上是Who-、What-、How-三元组之间的关系，也就是Who-对What-进行How-的操作，也就是“主体”对“客体”的操作。"></a></h3><p><strong>Who：是权限的拥有者或主体（如：User，Role）。</strong></p>
<p><strong>What：是操作或对象（operation，object）。</strong></p>
<p><strong>How：具体的权限（Privilege,正向授权与负向授权）。</strong></p>
<h2 id="组成">组成<a class="post-anchor" href="#组成"></a></h2><h3 id="User">User<a class="post-anchor" href="#User"></a></h3><p><strong>用户</strong></p>
<h3 id="Role">Role<a class="post-anchor" href="#Role"></a></h3><p><strong>角色</strong></p>
<p><strong>分类</strong></p>
<ul>
<li><p>admin</p>
</li>
<li><p>user</p>
</li>
<li><p>……</p>
</li>
</ul>
<h3 id="Resource-Permission">Resource(Permission)<a class="post-anchor" href="#Resource-Permission"></a></h3><p><strong>权限/资源</strong></p>
<p><strong>分类</strong></p>
<ul>
<li><p>功能权限</p>
<ul>
<li>模块</li>
</ul>
</li>
<li><p>菜单权限</p>
<ul>
<li>页内按钮操作</li>
</ul>
</li>
<li><p>数据级</p>
</li>
<li><p>uri权限</p>
<ul>
<li><p>页面，代表前端路由地址</p>
</li>
<li><p>按钮，代表后端接口地址</p>
</li>
</ul>
</li>
</ul>
<h2 id="扩展">扩展<a class="post-anchor" href="#扩展"></a></h2><p>用户组</p>
<p>菜单</p>
<h2 id="分类">分类<a class="post-anchor" href="#分类"></a></h2><h3 id="基本模型RBAC0">基本模型RBAC0<a class="post-anchor" href="#基本模型RBAC0"></a></h3><p><strong>介绍</strong></p>
<ul>
<li><p>RBAC0是基础，很多产品只需基于RBAC0就可以搭建权限模型了。<br>在这个模型中，我们把权限赋予角色，再把角色赋予用户。用户和角色，角色和权限都是多对多的关系。<br>用户拥有的权限等于他所有的角色持有权限之和。</p>
</li>
<li><p>举例</p>
<ul>
<li>譬如我们做一款企业管理产品，如果按传统权限模型，给每一个用户赋予权限则会非常麻烦，并且做不到批量修改用户权限。<br>这时候，可以抽象出几个角色，譬如销售经理、财务经理、市场经理等，然后把权限分配给这些角色，再把角色赋予用户。<br>这样无论是分配权限还是以后的修改权限，只需要修改用户和角色的关系，或角色和权限的关系即可，更加灵活方便。<br>此外，如果一个用户有多个角色，譬如王先生既负责销售部也负责市场部，那么可以给王先生赋予两个角色，即销售经理+市场经理，这样他就拥有这两个角色的所有权限。</li>
</ul>
</li>
</ul>
<p><strong>RBAC0模型图</strong></p>
<ul>
<li>……</li>
</ul>
<p><strong>RBAC0适用场景</strong></p>
<p><strong>评价</strong></p>
<h3 id="角色分层模型RBAC1">角色分层模型RBAC1<a class="post-anchor" href="#角色分层模型RBAC1"></a></h3><p><strong>RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念。<br>简单理解就是，给角色可以分成几个等级，每个等级权限不同，从而实现更细粒度的权限管理。</strong></p>
<hr>
<p><strong>举例</strong></p>
<ul>
<li>基于之前RBAC0的例子，我们又发现一个公司的销售经理可能是分几个等级的，譬如除了销售经理，还有销售副经理，而销售副经理只有销售经理的部分权限。<br>这时候，我们就可以采用RBAC1的分级模型，把销售经理这个角色分成多个等级，给销售副经理赋予较低的等级即可。</li>
</ul>
<h3 id="角色限制模型RBAC2">角色限制模型RBAC2<a class="post-anchor" href="#角色限制模型RBAC2"></a></h3><p><strong>RBAC2同样建立在RBAC0基础之上，仅是对用户、角色和权限三者之间增加了一些限制。<br>这些限制可以分成两类，即静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。</strong></p>
<ul>
<li><p>静态职责分离SSD(Static Separation of Duty)</p>
</li>
<li><p>动态职责分离DSD(Dynamic Separation of Duty)。</p>
</li>
</ul>
<hr>
<p><strong>举例</strong></p>
<ul>
<li>还是基于之前RBAC0的例子，我们又发现有些角色之间是需要互斥的，譬如给一个用户分配了销售经理的角色，就不能给他再赋予财务经理的角色了，否则他即可以录入合同又能自己审核合同；<br>再譬如，有些公司对角色的升级十分看重，一个销售员要想升级到销售经理，必须先升级到销售主管，这时候就要采用先决条件限制了。</li>
</ul>
<h3 id="统一模型RBAC3">统一模型RBAC3<a class="post-anchor" href="#统一模型RBAC3"></a></h3><p><strong>RBAC3是RBAC1和RBAC2的合集，所以RBAC3既有角色分层，也包括可以增加各种限制。</strong></p>
<p><strong>RBAC3= RBAC1 + RBAC2</strong></p>
<h3 id="基于RBAC的延展——用户组">基于RBAC的延展——用户组<a class="post-anchor" href="#基于RBAC的延展——用户组"></a></h3><p><strong>基于RBAC模型，还可以适当延展，使其更适合我们的产品。譬如增加用户组概念，直接给用户组分配角色，再把用户加入用户组。<br>这样用户除了拥有自身的权限外，还拥有了所属用户组的所有权限。</strong></p>
<hr>
<p><strong>譬如，我们可以把一个部门看成一个用户组，如销售部，财务部，再给这个部门直接赋予角色，使部门拥有部门权限，这样这个部门的所有用户都有了部门权限。<br>用户组概念可以更方便的给群体用户授权，且不影响用户本来就拥有的角色权限。</strong></p>
<h2 id="实例">实例<a class="post-anchor" href="#实例"></a></h2><h3 id="实体">实体<a class="post-anchor" href="#实体"></a></h3><p><strong>用户表user</strong></p>
<ul>
<li><p>id</p>
</li>
<li><p>……</p>
<ul>
<li>其他用户相关信息</li>
</ul>
</li>
</ul>
<p><strong>角色表role</strong></p>
<ul>
<li><p>id</p>
</li>
<li><p>pid</p>
</li>
<li><p>name</p>
<ul>
<li>角色名称</li>
</ul>
</li>
<li><p>status</p>
<ul>
<li>是否禁用</li>
</ul>
</li>
<li><p>updated_time</p>
</li>
<li><p>created_time</p>
</li>
</ul>
<p><strong>权限表permission</strong></p>
<ul>
<li><p>id</p>
</li>
<li><p>name</p>
</li>
<li><p>url</p>
</li>
<li><p>status</p>
</li>
</ul>
<h3 id="关系">关系<a class="post-anchor" href="#关系"></a></h3><p><strong>用户角色表 UA</strong></p>
<ul>
<li><p>id</p>
</li>
<li><p>uid</p>
</li>
<li><p>role_id</p>
</li>
<li><p>created_time</p>
</li>
</ul>
<p><strong>权限角色表 PA</strong></p>
<ul>
<li><p>id</p>
</li>
<li><p>role_id</p>
</li>
<li><p>per_id</p>
</li>
<li><p>created_time</p>
</li>
</ul>
<h1 id="其他"><strong>其他</strong><a class="post-anchor" href="#其他"></a></h1><h2 id="ABAC">ABAC<a class="post-anchor" href="#ABAC"></a></h2><p>基于属性的权限验证（ABAC: Attribute-Based Access Control）</p>
<h2 id="DAC">DAC<a class="post-anchor" href="#DAC"></a></h2><h3 id="案例">案例<a class="post-anchor" href="#案例"></a></h3><p><strong>文件系统</strong></p>
<p>自主访问控制（DAC: Discretionary Access Control）</p>
<h2 id="MAC">MAC<a class="post-anchor" href="#MAC"></a></h2><p>强制访问控制（MAC: Mandatory Access Control）</p>
<h3 id="案例-1">案例<a class="post-anchor" href="#案例-1"></a></h3><p><strong>政府机密文件</strong></p>
<h3 id="要素">要素<a class="post-anchor" href="#要素"></a></h3><p><strong>控制体</strong></p>
<p><strong>权限标识</strong></p>
<p><strong>用户</strong></p>
<ul>
<li>权限标识</li>
</ul>
<h2 id="SAM">SAM<a class="post-anchor" href="#SAM"></a></h2><p>SAM(Security Access Manager)</p>
<p>有赞</p>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
        <category>导图</category>
      </categories>
      <tags>
        <tag>鉴权</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链共识算法分类总结</title>
    <url>/2022/02122235/</url>
    <content><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><div class="post-mindmap">
  <iframe class="mindmap" id="mindmap" src="区块链 - 技术 - 共识算法(机制).html"></iframe>
  <div class="r">
  <span class="iconfont icon-close"></span>
    <div class="tip"></div>
    <a class="fullscreen-button">Full Screen</a>
</div>
</div>
  <script type="text/javascript">
    var sonWidth = document.getElementById("mindmap").offsetWidth;
    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";
</script>




<h1 id="概述"><strong>概述</strong><a class="post-anchor" href="#概述"></a></h1><h2 id="介绍">介绍<a class="post-anchor" href="#介绍"></a></h2><p>数据同步的方法</p>
<p>所谓“共识机制”，是通过特殊节点的投票，在很短的时间内完成对交易的验证和确认；</p>
<h3 id="对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。">对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。<a class="post-anchor" href="#对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。"></a></h3><p><strong>再通俗一点来讲，如果中国一名微博大V、美国一名虚拟币玩家、一名非洲留学生和一名欧洲旅行者互不相识，<br>但他们都一致认为你是个好人，那么基本上就可以断定你这人还不坏。</strong></p>
<p>指可以使用所有节点对某一种状态达成一致的方式，<br>有共识机制去中心化才有意义，才具备可信度，否则只是数据共享</p>
<p>目前主流的共识机制有：POW、POS、DPOS、PBFT等</p>
<p>所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。 当加入区块链的节点足够多的时候，基本上不可能伪造出一条不存在的记录，从而杜绝了造假的可能。</p>
<h3 id="区块链的共识机制通常包含了两个方面">区块链的共识机制通常包含了两个方面<a class="post-anchor" href="#区块链的共识机制通常包含了两个方面"></a></h3><p><strong>达成共识的计算机算法，即共识算法（Consensus Algorithm）</strong></p>
<p><strong>达成共识的规则，即共识规则（Consensus Rule）</strong></p>
<h3 id="分布式一致性算法（共识机制）">分布式一致性算法（共识机制）<a class="post-anchor" href="#分布式一致性算法（共识机制）"></a></h3><p><strong>什么是共识， 什么是共识算法？</strong></p>
<ul>
<li>……</li>
</ul>
<hr>
<p><strong>Paxos</strong></p>
<p><strong>Raft</strong></p>
<p>所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。<br>区块链提出了四种不同的共识机制，适用于不同的应用场景，在效率和安全性之间取得平衡。</p>
<h3 id="区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中：">区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中：<a class="post-anchor" href="#区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中："></a></h3><p><strong>“少数服从多数”并不完全指节点个数，也可以是计算能力、股权数或者其他的计算机可以比较的特征量。</strong></p>
<p><strong>“人人平等”是当节点满足条件时，所有节点都有权优先提出共识结果、直接被其他节点认同后并最后有可能成为最终共识结果。 [8]</strong></p>
<p>以比特币为例，采用的是工作量证明，只有在控制了全网超过51%的记账节点的情况下，才有可能伪造出一条不存在的记录。<br>当加入区块链的节点足够多的时候，这基本上不可能，从而杜绝了造假的可能。</p>
<p>即便在网络通信可靠情况下，<br>一个可扩展的分布式系统的共识问题通用解法的下限是——没有下限（无解）</p>
<h2 id="目的">目的<a class="post-anchor" href="#目的"></a></h2><p>让分布式数据记录不可逆</p>
<p>选择节点产生区块</p>
<h2 id="作用">作用<a class="post-anchor" href="#作用"></a></h2><h3 id="分布式系统对某个提案，大部分节点达成一致意见的过程">分布式系统对某个提案，大部分节点达成一致意见的过程<a class="post-anchor" href="#分布式系统对某个提案，大部分节点达成一致意见的过程"></a></h3><p><strong>在区块链系统中没有像银行一样的中心化机构，所以在进行传输信息、价值转移时， 共识机制解决并保证每一笔交易在所有记帐节点上的一致性和正确性问题。<br> 区块链的这种新的共识机制使其在不依靠中心化组织的情况下，依然大规模高效协作完成运转</strong></p>
<p><strong>数据一致性要解决哪些问题</strong></p>
<ul>
<li><p>以谁的数据为准</p>
<ul>
<li><p>任何结点都可以修改自己所下载的账本，也就是任何一个人都可以伪造账本</p>
</li>
<li><p>在去中心化的网络下，我们只能认为，大多数人认识的数据是对的。<br>只要我控制了一半以上的结点，我让这 “ 大多数人 “ 伪造同一份账本，那么相当于整个账本都被我修改过来了</p>
</li>
<li><p>因为在没有服务器的去中心化的网络下，所谓的真理只不过是大多数人同意的东西。</p>
</li>
</ul>
</li>
<li><p>“ 大多数人 “ 的问题</p>
<ul>
<li>是人数吗？在网络世界里，我可以用程序模拟出无穷多的 “ 人 “ 出来投票，<br>所以，用人数来解决去中心化的问题，在分不清是人还是狗，是生物还是程序的计算机世界里，是一件很愚蠢的事。</li>
</ul>
</li>
<li><p>意见分歧问题</p>
<ul>
<li>如果在同一个时刻，有多个人都在告诉其它人，这账应该这么记 有人说，我转了10块给gg，又有人说，xx转了20块给我</li>
</ul>
</li>
</ul>
<p>提案，包括：发生顺序、某个键对应的值、谁是主节点…，比较宽泛</p>
<p>多节点系统最关键的是对多个事件的顺序进行共识，即排序</p>
<h2 id="相关概念">相关概念<a class="post-anchor" href="#相关概念"></a></h2><h3 id="共识">共识<a class="post-anchor" href="#共识"></a></h3><p><strong>在分布式系统中多个节点之间对某个事情达成一致看法的过程</strong></p>
<p><strong>所有节点对区块的同步</strong></p>
<h3 id="共识机制">共识机制<a class="post-anchor" href="#共识机制"></a></h3><p><strong>不同群体所寻求的共同的认识、价值、想法等，在某一方面达成的一致意见。 共识机制就是确定达成某种共识和维护共识的方式</strong></p>
<h3 id="拜占庭将军问题">拜占庭将军问题<a class="post-anchor" href="#拜占庭将军问题"></a></h3><p><strong>定义</strong></p>
<ul>
<li><p>一种分布式场景下的一致性问题</p>
<ul>
<li>叛徒少于1/3，问题可解</li>
</ul>
</li>
<li><p>莱斯利·兰波特在其论文[1]中描述了如下问题：</p>
<ul>
<li>一组拜占庭将军分别各率领一支军队共同围困一座城市。 为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。 因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。 因为各位将军分处城市不同方向，他们只能通过信使互相联系。 在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军， 这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</li>
</ul>
</li>
<li><p>系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。 假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。 这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。 这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。</p>
</li>
<li><p>由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。 而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。 因此很难通过保证人员可靠性及通讯可靠性来解决问题。</p>
</li>
<li><p>假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。 在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。</p>
</li>
<li><p>上述的故事映射到计算机系统里，将军便成了计算机，而信差就是通信系统。 虽然上述的问题涉及了电子化的决策支持与信息安全，却没办法单纯的用密码学与数字签名来解决。 因为电路错误仍可能影响整个加密过程，这不是密码学与数字签名算法在解决的问题。 因此计算机就有可能将错误的结果提交去，亦可能导致错误的决策。</p>
</li>
</ul>
<p><strong>拜占庭容错<br>ByzantineFaultTolerance</strong></p>
<ul>
<li><p>BFT</p>
</li>
<li><p>当失效节点不超过三分之一可达共识</p>
</li>
</ul>
<p><strong>拜占庭容错系统</strong></p>
<p><strong>共识算法</strong></p>
<ul>
<li><p>非拜占庭错误的情况</p>
<ul>
<li><p>Paxos</p>
<ul>
<li>基于分布式两阶段提交理论</li>
</ul>
</li>
<li><p>Raft</p>
</li>
</ul>
</li>
<li><p>容忍拜占庭错误的情况</p>
<ul>
<li><p>BFT</p>
<ul>
<li>PBFT</li>
</ul>
</li>
<li><p>POW</p>
</li>
<li><p>POS</p>
</li>
<li><p>DPOS</p>
</li>
</ul>
</li>
</ul>
<h3 id="错误">错误<a class="post-anchor" href="#错误"></a></h3><p><strong>拜占庭错误</strong></p>
<ul>
<li><p>Byzantine Fault Tolerance(BFT)</p>
</li>
<li><p>性能差，容忍不超过1/3的故障节点</p>
</li>
<li><p>PBFT（Practical BFT) 确定性系列算法</p>
<ul>
<li>不可逆，为最终结果</li>
</ul>
</li>
<li><p>PoW 概率算法</p>
<ul>
<li>临时结果，随时间推移或某种强化，被推翻的概率越小</li>
</ul>
</li>
<li><p>XFT（Cross Fault Tolerance)算法，提升处理速度</p>
</li>
<li><p>Algorand算法，实现更好的性能（1000+TPS）</p>
</li>
</ul>
<p><strong>故障错误</strong></p>
<ul>
<li><p>Crash Fault Tolerance(CFT)</p>
</li>
<li><p>性能好，容忍不超过1/2的故障节点</p>
</li>
<li><p>Paxos、Raft及变种算法</p>
</li>
</ul>
<h2 id="评价标准">评价标准<a class="post-anchor" href="#评价标准"></a></h2><p>资源消耗</p>
<h3 id="性能效率">性能效率<a class="post-anchor" href="#性能效率"></a></h3><p><strong>Pow</strong></p>
<ul>
<li>低</li>
</ul>
<p><strong>Pos</strong></p>
<ul>
<li>较高</li>
</ul>
<p><strong>DPoS</strong></p>
<ul>
<li>高</li>
</ul>
<p><strong>PBFT</strong></p>
<ul>
<li>高</li>
</ul>
<h3 id="扩展性">扩展性<a class="post-anchor" href="#扩展性"></a></h3><p><strong>对不同加密算法的支持</strong></p>
<p>安全性</p>
<h2 id="特点">特点<a class="post-anchor" href="#特点"></a></h2><h3 id="一致性">一致性<a class="post-anchor" href="#一致性"></a></h3><p><strong>分布式网络数据的一致性</strong></p>
<ul>
<li><p>一个公司内的分布式系统中的结点是被假设成可信任的</p>
</li>
<li><p>而在去中心化的网络下，所有结点要被假设成不可信任的</p>
</li>
<li><p>cap定理</p>
<ul>
<li>在一致性、可用性和分区容忍性上只能三选两。在区块链的 P2P 网络下也是很类似的，在去中心化、安全和高性能中，我们也只能选两个</li>
</ul>
</li>
</ul>
<p><strong>所有诚实节点保存的前缀一致</strong></p>
<h3 id="有效性">有效性<a class="post-anchor" href="#有效性"></a></h3><p><strong>由诚实节点发送的数据会达到其他诚实节点</strong></p>
<h2 id="区块链同步基本流程">区块链同步基本流程<a class="post-anchor" href="#区块链同步基本流程"></a></h2><p>发送节点将新的数据全网广播</p>
<p>接收节点对数据进行校验，数据记录纳入区块</p>
<p>全网所有接收节点对区块执行共识算法</p>
<p>区块通过共识后，纳入区块链存储。</p>
<h2 id="问题">问题<a class="post-anchor" href="#问题"></a></h2><h3 id="隔离见证">隔离见证<a class="post-anchor" href="#隔离见证"></a></h3><p><strong>交易和结算分开</strong></p>
<p><strong>原因是当前比特币确认时间过长</strong></p>
<ul>
<li>达到安全的状态需6个区块确认，约1小时</li>
</ul>
<h3 id="双花">双花<a class="post-anchor" href="#双花"></a></h3><p><strong>双重支付</strong></p>
<ul>
<li>同一个钱，用两次</li>
</ul>
<p><strong>理论上说，超过全网51%的算力，就能改账本，完成双花</strong></p>
<p><strong>预防双花</strong></p>
<ul>
<li>后面查资料看看呗</li>
</ul>
<h1 id="种类"><strong>种类</strong><a class="post-anchor" href="#种类"></a></h1><h2 id="公链">公链<a class="post-anchor" href="#公链"></a></h2><h3 id="工作量证明-Proof-of-Work，简称POW">工作量证明(Proof of Work，简称POW)<a class="post-anchor" href="#工作量证明-Proof-of-Work，简称POW"></a></h3><p><strong>定义</strong></p>
<ul>
<li><p>工作量证明</p>
</li>
<li><p>可简单理解为一份证明，证明你做过一定量的工作。<br>通过查看工作结果，就能知道你完成了指定量的工作。<br>区块链共识算法用的最多的就是POW。比特币和以太坊都是基于POW的共识机制。</p>
<ul>
<li><p>例</p>
<ul>
<li><p>比特币在区块的生成过程中使用的就是POW机制，</p>
</li>
<li><p>简单理解就是大家共同争夺记账权利，谁先抢到并正确完成记账工作，谁就得到系统的奖励，奖励为比特币，也就是所谓的“挖矿”。</p>
</li>
<li><p>矿工（参与挖矿的人）通过计算机的算力去完成这个记账工作，这个拥有计算能力的专业计算机就是所谓的“矿机”。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>目前有很多数字资产用pow发行新币</p>
</li>
<li><p>开放性和匿名性，意味着任何节点可以随时进入这个网络， 即使是恶意节点。 </p>
</li>
<li><p>区块的生成和发送， 意味着对整个区块链状态的修改。 </p>
<ul>
<li><p>对状态的修改，必须要付出一定的成本， 这里面就是算力， 增大攻击的成本。</p>
<ul>
<li>……</li>
</ul>
</li>
</ul>
</li>
<li><p>在一个不可信的网络环境（节点不可信，网络不可信）下， 如何就状态，在不同的节点之间达成一致</p>
</li>
<li><p>新区块生成条件</p>
<ul>
<li><p>……</p>
<ul>
<li><p>要求 10 分钟一个区块， 2016 个区块的时间就是 2 个星期 ( 2016 * 10 * 60 / ( 24 * 60 * 60) = 14 days)</p>
</li>
<li><p>根据时间偏差来对应的调整难度值</p>
</li>
<li><p>调整幅度有最大/最小比例</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>比喻</p>
<ul>
<li><p>谁的算力大，谁就更大的几率做出记账</p>
<ul>
<li>举例子：比如生成的hash后面几位需要为0.你计算了多少次拿到了这个结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>评价</strong></p>
<ul>
<li><p>特点</p>
<ul>
<li><p>1、算一道很难的题，系统给予挖矿奖励</p>
</li>
<li><p>2、多劳多得</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>1、所有节点均可参与，记账权公平的分派到每个节点，去中心化</p>
</li>
<li><p>2、多劳多得，矿工积极性高</p>
</li>
<li><p>3、安全性高，欺诈成本高，如果能够欺诈成功，那么做诚实节点收益更大</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>1、主流矿池垄断严重，存在51%算攻击风险</p>
</li>
<li><p>2、浪费资源严重</p>
</li>
<li><p>3、持币人没有话语权，算力决定一切</p>
</li>
<li><p>4、网络性能低，共识时间长</p>
</li>
</ul>
</li>
</ul>
<p><strong>评价</strong></p>
<ul>
<li><p>优点</p>
<ul>
<li><p>完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。</p>
</li>
<li><p>只要网络破坏者的算力不超过全网总算力的50%，网络的交易状态就能达成一致，并不可篡改历史记录。</p>
</li>
<li><p>投入越多算力，获得记账权概率越大，越有可能产生新的区块奖励。</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>目前比特币挖矿造成大量的算力和能源浪费。</p>
</li>
<li><p>挖矿的激励机制也造成挖矿算力的高度集中</p>
<ul>
<li><p>随着算力的集中，渐渐向中心化演变</p>
<ul>
<li>算力集中于占据了大多数算力矿池</li>
</ul>
</li>
</ul>
</li>
<li><p>结算周期长，每秒最多结算7笔交易，不适合商业应用。</p>
</li>
</ul>
</li>
</ul>
<p><strong>POW – 农耕文明</strong></p>
<ul>
<li><p>需要“工作量证明”来声明新区块</p>
</li>
<li><p>pow：工作量证明，放弃了高性能</p>
<ul>
<li><p>挖矿：用大规模的计算来找到一个符合系统要求的区块 ID</p>
<ul>
<li>要找到符合条件的区块 ID 只能通过暴力穷举的方式，所以要付出大量的系统计算资源和电力。</li>
</ul>
</li>
<li><p>修改几乎变得不可能</p>
<ul>
<li>试想，如果生成一个区块需要大量的长时间的计算力。也就是在世界上最好的电脑集群下计算 10 分钟才能打好一个包，那么，当我们要去修改数据内容的时候，这个过程也是一样的。前面说过，如果你要伪造一个块，那么你就要修改后面所有的块，修改一个块的成本如此之高，那么修改整个链的成本也就非常之高了</li>
</ul>
</li>
<li><p>能掌握 51% 的算力的人也变得几乎不可能</p>
<ul>
<li>除了伪造一条链的成本很高，还要控制大多数人的算力，这意味着，是一个非常大的金钱的投入。这两个难度加起来，几乎不太可能。</li>
</ul>
</li>
<li><p>解决分歧</p>
<ul>
<li>一方面，这么大的工作量找出来的区块 ID，已经有效地降低了大家有意见冲突的概率。<br>另一方面，就算是出现了合法冲突的区块（同时出现了多个合理的区块，即区块链出现分支 / 分叉），也就是多个合法的账本。而因为挖矿的成本太高，导致要同时跟进多个账本是不可能的，所以矿工们只能赌跟其中一个。<br>大多数人所选择的那一个分支的链就会越来越多，于是另外一边也就无人问津，从而作废了。</li>
</ul>
</li>
<li><p>pow机制存在的问题</p>
<ul>
<li><p>越来越中心化地记账</p>
</li>
<li><p>越来越跑不动</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>工作量证明机制：pow</strong></p>
<ul>
<li><p>工作量证明机制即对于工作量的证明，<br>是生成要加入到区块链中的一笔新的交易信息(即新区块)时必须满足的要求。</p>
</li>
<li><p>在基于工作量证明机制构建的区块链网络中，节点通过计算随机哈希散列的数值解争夺记账权，求得正确的数值解以生成区块的能力是节点算力的具体表现。<br>工作量证明机制具有完全去中心化的优点，在以工作量证明机制为共识的区块链中，节点可以自由进出。</p>
</li>
<li><p>大家所熟知的比特币网络就应用工作量证明机制来生产新的货币。<br>然而，由于工作量证明机制在比特币网络中的应用已经吸引了全球计算机大部分的算力，其他想尝试使用该机制的区块链应用很难获得同样规模的算力来维持自身的安全。<br>同时，基于工作量证明机制的挖矿行为还造成了大量的资源浪费，达成共识所需要的周期也较长，因此该机制并不适合商业应用。</p>
</li>
</ul>
<p><strong>工作量证明（POW）</strong></p>
<ul>
<li><p>问题</p>
<ul>
<li>公地悲剧问题</li>
</ul>
</li>
</ul>
<p><strong>使用项目</strong></p>
<ul>
<li>比特币、以太坊、比原链等</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li><p>原理</p>
<ul>
<li>通过找到合理随机数争夺记账权</li>
</ul>
</li>
</ul>
<h3 id="权益证明-Proof-of-Stake，简称POS">权益证明(Proof of Stake，简称POS)<a class="post-anchor" href="#权益证明-Proof-of-Stake，简称POS"></a></h3><p><strong>定义</strong></p>
<ul>
<li><p>通过持有Token（代币）的数量和时长来决定你获得记账的机率，<br>类似于股票的分红制度，持有股权越多的人就能够获得更多的分红。<br>Token相当于区块链系统的权益。</p>
</li>
<li><p>2012年，化名Sunny King的网友推出了Peercoin，该加密电子货币采用工作量证明机制发行新币，<br>采用权益证明机制维护网络安全，这是权益证明机制在加密电子货币中的首次应用。</p>
<ul>
<li><p>与要求证明人执行一定量的计算工作不同，权益证明要求证明人提供一定数量加密货币的所有权即可。</p>
</li>
<li><p>权益证明机制的运作方式是：</p>
<ul>
<li>当创造一个新区块时，矿工需要创建一个“币权”交易，交易会按照预先设定的比例把一些币发送给矿工本身。<br>权益证明机制根据每个节点拥有代币的比例和时间，依据算法等比例地降低节点的挖矿难度，从而加快了寻找随机数的速度。<br>这种共识机制可以缩短达成共识所需的时间，但本质上仍然需要网络中的节点进行挖矿运算。<br>因此，PoS机制并没有从根本上解决PoW机制难以应用于商业领域的问题。</li>
</ul>
</li>
</ul>
</li>
<li><p>随着代币的集中，渐渐向中心化演变</p>
</li>
<li><p>需要“财产证明”来声明新区块</p>
<ul>
<li>根据持有数字货币的数量与时间，进行利息发放和区块产生的机制</li>
</ul>
</li>
<li><p>比喻</p>
<ul>
<li><p>谁有的区块链资产多大，谁就更大的几率做记账</p>
</li>
<li><p>资本主义模式，钱越多，责任越多</p>
</li>
</ul>
</li>
</ul>
<p><strong>评价</strong></p>
<ul>
<li><p>优点</p>
<ul>
<li><p>降低了PoW机制的资源浪费。</p>
</li>
<li><p>加快了运算速度，也可以理解为工作量证明的升级版</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>拥有币龄越长的节点获得记账权的几率越大，<br>容易导致马太效应，富者越富，权益会越来越集中,从而失去公正性。</li>
</ul>
</li>
</ul>
<p><strong>POS – 资本主义</strong></p>
<ul>
<li><p>pos：股权证明，放弃了安全</p>
<ul>
<li><p>在 PoS 机制下，矿工不在叫矿工，而是叫 Validator（校验者）</p>
</li>
<li><p>pow 好像是 “ 多劳多得 “ 的社会，而 pos 更像是 “ 资本主义 “ 社会，钱越多的人越有话语权</p>
</li>
<li><p>pos的好处</p>
<ul>
<li><p>不需要那么费劲的挖矿了。那样浪费电力不环保地挖矿的确有点太糟糕了。PoS 很明显地解决了这个问题。</p>
</li>
<li><p>在 PoS 下，你需要有 51% 的财富，你才可以发起攻击，这相对于算力而言需要更多的成本。 设想一下，你得拥有 51% 的比特币，你才能黑了比特币，然而，如果你有 51% 的财富，你为什么要黑了这个系统，自己把自己干死呢？</p>
</li>
</ul>
</li>
<li><p>pos潜在的问题</p>
<ul>
<li>双重支付的问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3、POS(股权证明)</strong></p>
<ul>
<li><p>特点</p>
<ul>
<li><p>1、不挖矿，依靠币龄(币持有数量 * 持有天数)决定记账权，利息即为奖励，记账后币龄清零</p>
</li>
<li><p>2、按钱分配，钱生钱</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>1、在一定程度上缩短了共识达成的时间</p>
</li>
<li><p>2、节约资源</p>
</li>
<li><p>3、防作弊，币龄越大，获得记账权几率越大、避免51%攻击，会因为攻击会使自己权益受损</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>1、数字货币过于集中化，富者越来越富有，散户参与积极性低</li>
</ul>
</li>
<li><p>项目</p>
<ul>
<li>ADA等</li>
</ul>
</li>
</ul>
<h3 id="委托权益证明-Delegated-Proof-of-Stake，简称DPOS">委托权益证明(Delegated Proof of Stake，简称DPOS)<a class="post-anchor" href="#委托权益证明-Delegated-Proof-of-Stake，简称DPOS"></a></h3><p><strong>概述</strong></p>
<ul>
<li><p>股份授权证明机制</p>
<ul>
<li>Delegated Proof Of Stake</li>
</ul>
</li>
<li><p>股份授权证明机制是一种新的保障网络安全的共识机制。<br>它在尝试解决传统的PoW机制和PoS机制问题的同时，<br>还能通过实施科技式的民主抵消中心化所带来的负面效应。</p>
<ul>
<li><p>股份授权证明机制与董事会投票类似，该机制拥有一个内置的实时股权人投票系统，就像系统随时都在召开一个永不散场的股东大会，所有股东都在这里投票决定公司决策。<br>基于DPoS机制建立的区块链的去中心化依赖于一定数量的代表，而非全体用户。<br>在这样的区块链中，全体节点投票选举出一定数量的节点代表，由他们来代理全体节点确认区块、维持系统有序运行。<br>同时，区块链中的全体节点具有随时罢免和任命代表的权力。如果必要，全体节点可以通过投票让现任节点代表失去代表资格，重新选举新的代表，实现实时的民主。</p>
</li>
<li><p>股份授权证明机制可以大大缩小参与验证和记账节点的数量，从而达到秒级的共识验证。<br>然而，该共识机制仍然不能完美解决区块链在商业中的应用问题，因为该共识机制无法摆脱对于代币的依赖，而在很多商业应用中并不需要代币的存在。</p>
</li>
</ul>
</li>
<li><p>用户票选代理人。由代理人轮流生成新区块</p>
</li>
<li><p>代理人相互制约，确保不会伪造</p>
</li>
<li><p>类似董事会投票机制</p>
</li>
<li><p>代理权益证明，放弃了去中心化</p>
<ul>
<li><p>DPoS 已经开始把区块链的去中心化的初衷开始向中心化的地方演进了</p>
</li>
<li><p>DPoS 就是政治主义社会。<br>谁的选票多谁说话，但是感觉又回到了中心化架构中的 Leader 选举</p>
</li>
</ul>
</li>
<li><p>是基于POS衍生出的更专业的解决方案，类似于董事会投票，指拥有Token的人投票给固定的节点，选举若干代理人，由代理人负责验证和记账。<br>不同于POW和POS的全网都可以参与记账竞争，DPOS的记账节点在一定时间段内是确定的</p>
</li>
<li><p>通过不同的策略，不定时地选中一小群节点，这一小群节点做新区块的创建、验证、签名和相互监督。<br>这样就大幅度减少了区块创建和确认所需要消耗的时间和算力成本。</p>
</li>
<li><p>比喻</p>
<ul>
<li>每个有币节点投票，产生100名候选人。随机选取一个股东来产生区块。轮流记账</li>
</ul>
</li>
</ul>
<p><strong>评价</strong></p>
<ul>
<li><p>特点</p>
<ul>
<li><p>不挖矿</p>
</li>
<li><p>每年按比例增发代币</p>
</li>
<li><p>奖励超级节点</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>相较pow，dpos大幅提高区块链处理数据的能力，甚至可以实现秒到账，同时也大幅降低维护区块链网络安全的费用</p>
</li>
<li><p>高效、扩展性强</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>去中心程度较弱，节点代理是人为选出的，公平性相比POS较低，依赖于代币的增发来维持代理节点的稳定性</p>
</li>
<li><p>21个节点太少，非去中心化，而是多中心化</p>
</li>
</ul>
</li>
</ul>
<p><strong>项目</strong></p>
<ul>
<li>EOS</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>DPOS – 社会主义</li>
</ul>
<h2 id="联盟链">联盟链<a class="post-anchor" href="#联盟链"></a></h2><h3 id="实用拜占庭容错算法（Practical-Byzantine-Fault-Tolerance，简称PBFT）">实用拜占庭容错算法（Practical Byzantine Fault Tolerance，简称PBFT）<a class="post-anchor" href="#实用拜占庭容错算法（Practical-Byzantine-Fault-Tolerance，简称PBFT）"></a></h3><p><strong>概述</strong></p>
<ul>
<li><p>Practical Byzantine Fault Tolerance</p>
</li>
<li><p>PBFT，是联盟币的共识算法的基础。</p>
</li>
<li><p>实现了在有限个节点的情况下的拜占庭问题，有3f+1的容错性，并同时保证一定的性能。</p>
</li>
<li><p>该算法在保证活性和安全性的前提下提供了（n-1）/3的容错性。<br>主要实现的有拜占庭容错的NFS文件系统。</p>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li><p>联盟链和私有链</p>
<ul>
<li>Hyperledger组织下的Fabric项目使用的是该算法</li>
</ul>
</li>
</ul>
<h2 id="私链">私链<a class="post-anchor" href="#私链"></a></h2><h3 id="验证池共识机制Pool">验证池共识机制Pool<a class="post-anchor" href="#验证池共识机制Pool"></a></h3><p><strong>定义</strong></p>
<ul>
<li><p>Pool验证池</p>
</li>
<li><p>Pool验证池基于传统的分布式一致性技术建立，并辅之以数据验证机制，是目前区块链中广泛使用的一种共识机制。</p>
<ul>
<li>基于传统的分布式一致性技术，加上数据验证机制，是目前行业链大范围在使用的共识机制。</li>
</ul>
</li>
<li><p>Pool验证池不需要依赖代币就可以工作，在成熟的分布式一致性算法(Pasox、Raft)基础之上，<br>可以实现秒级共识验证，更适合有多方参与的多中心商业模式。<br>不过，Pool验证池也存在一些不足，例如该共识机制能够实现的分布式程度不如PoW机制等。</p>
</li>
</ul>
<p><strong>评价</strong></p>
<ul>
<li><p>优点</p>
<ul>
<li><p>不需要依赖代币也可以实现秒级共识验证</p>
<ul>
<li>不需要代币也可以工作，在成熟的分布式一致性算法（Pasox,Raft）基础上实现秒级共识验证。</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>去中心化程度弱，更适合多方参与的多中心商业模式</p>
<ul>
<li>去中心化程度不如bitcoin，适合多中心的商业模式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="paxos">paxos<a class="post-anchor" href="#paxos"></a></h3><p><strong>概述</strong></p>
<ul>
<li><p>Paxos算法是莱斯利・兰伯特( Leslie Lamport,现就职于微软研究院)于1990年提出的，是一种基于消息传递的一致性算法。<br>莱斯利・兰伯特于2013年获得了图灵奖。他的分布式计算理论莫定了这门学科的基础。</p>
</li>
<li><p>菜斯利・兰伯特在1978年发表了论文《分布式系统内的时间、时钟事件顺序》(Time, Clocks, and the Ordering of Events in a Distributed System),<br>这篇论文成为目前计算机科学史上被引用最多的文献。他的论文为并发系统的规范与验证课题的研究贡献了核心原理。</p>
</li>
<li><p>Paxos算法是在莱斯利・兰伯特的论文 The Part- Time Parliamen中提出的。<br>在论文中，他以故事的方式讲述了 Paxos算法</p>
<ul>
<li><p>古希腊有一个叫 Paxos的岛屿，是爱琴海上的一个小島， Paxos是一个兴盛的商业贸易中心。<br>在这个岛屿上，法律的制定与修订通过议会表决的形式进行，而非传统的神权治。</p>
</li>
<li><p>所有法律都必须经由议会成员授票表决后才能生效实范，而且已通过的律法必须被记录在案。</p>
</li>
<li><p>在岛上，商业繁荣，做生意赚钱才是头等大事，因此没有人愿意始终在议会大斤里从头到尾参与每一个法律表决的会议。<br>为此，每一个议员都来维护一个法律律簿，用来记录一系列已通过的法令，每个法令带有一个唯编号。<br>为了保持各个议员法律律薄内容的一致性，法律律簿是用擦不掉的墨水书写而成的，所以内容一旦书写就不能改变。</p>
</li>
<li><p>在议会中有多个角色的成员：议员和服务员。<br>服务员的工作是在比较曹杂的议会厅里传递信息，议员的工作是发起法律提案或将通过的法律记录在自己的法律律簿上。</p>
</li>
<li><p>由于议员和服务员有可能并不可靠，他们可能随时会因为各种事情临时甚至是彻底离开议会大斤，服务员也有可能重复传递消息，<br>当然也可能有新的议员在临时事务处理完毕后再回到议会大厅进行法律表决，<br>因此议会的协议要求保证在上述情况下能够正确地修订法律并且不会产生冲突。</p>
</li>
<li><p>在法律表决时，议员的角色分为 proposers和 acceptors</p>
</li>
<li><p>通过一个法律决议时，分为两个阶段：</p>
<ul>
<li><p>阶段1: prepare阶段</p>
<ul>
<li><p>proposer选择一个提案编号n,并将 prepare请求发送给 acceptors群体。</p>
</li>
<li><p>acceptor收到 prepare消息后，如提案的编号大于它已经回复的所有prepare消息，<br>则 acceptor将自己上次接受的提案回复给 proposer,并承诺不再回复小于n的提案；<br>如果提案的编号小于等于它已经回复的所有 prepare消息，则说明是重复消息，不再重复处理。</p>
</li>
</ul>
</li>
<li><p>阶段2:批准阶段</p>
<ul>
<li>当 proposer收到多数 acceptors对 prepare的回复后，就进入批准阶段。<br>它要向回复 prepare请求的 acceptors发送 accept请求。<br>acceptor收到accept请求后，则立即接受这个请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Paxos 问题是指分布式的系统中存在故障（crash fault），但不存在恶意（corrupt）节点的场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。<br>解决分布式系统中一致性问题的共识算法（Consensus Algorithm），其最基本的功能是为了在多个进程之间对某个值达成一致。<br>通过这个最基本功能，就可以在多个进程之间进行数据库、状态机、账本（区块链）等对象的同步。<br>被广泛应用在 Chubby、ZooKeeper 这样的分布式系统中。类似于两阶段提交算法</p>
</li>
</ul>
<p><strong>基本原理</strong></p>
<ul>
<li><p>三个角色</p>
<ul>
<li><ol>
<li>Proposer。<br>提案者，用于提出议案，提案的内容为：令 x=value，对同一轮提案，最多提议一个value </li>
</ol>
</li>
<li><ol start="2">
<li>Acceptor。<br>投票者，完全对等，在独立的时间轴执行提案投票</li>
</ol>
</li>
<li><ol start="3">
<li>Learner。<br>学习者，一个提案超过半数accpetor通过即可被chosen，其他未确定的Acceptor可以通过learner来同步结果</li>
</ol>
</li>
</ul>
</li>
<li><p>两阶段</p>
<ul>
<li><ol>
<li><p>Prepare阶段</p>
<ul>
<li><p>1.Proposer选择一个提案编号N，向所有的Acceptor广播Prepare(N)请求</p>
</li>
<li><p>2.Acceptor收到Prepare(N)请求，若提案编号N比之前接收的Prepare请求都要大，则承诺(Promise，将N记录下来)将不会接收提案编号比N小的提议，<br>并且带上之前Accept的提议中编号小于N的最大的提案value(没有则为NULL)。如果N比之前接受的提案编号小，则不予理会。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>Proposal阶段</p>
<ul>
<li><p>1.Proposer收到Acceptor的Promise。</p>
<ul>
<li><p>如果未超过半数的Accpetor回复承诺(Promise)则本次提案失败；</p>
</li>
<li><p>如果超过半数的Acceptor回复承诺，又分为不同情况：</p>
<ul>
<li><p>如果(回复承诺的)所有Acceptor都未接收过value(都为null)，<br>那么向所有的Acceptor发起(Propose)自己的value和提案编号N。</p>
</li>
<li><p>如果有部分Acceptor接收过value，那么从接受过的value中选择提案编号N最大对应的value作为本次提案的value，<br>提议编号仍然为N(此时Proposer不能提议自己的value，只能信任Acceptor通过的value，以达成收敛的效果)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.Acceptor接收到Proposal后，如果该提案编号N不等于自身当前承诺的编号(第一阶段记录的)，<br>不接受该请求，相等则将提案的value写入本地</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>理解</p>
<ul>
<li><p>分布式抢占锁</p>
<ul>
<li><p>Prepare阶段–申请加锁，Proposal阶段–修改并释放锁</p>
</li>
<li><p>只有超过半数的Acceptor同意，加锁才成功；<br>否则可能存在多个申请加锁的客户端</p>
</li>
<li><p>每个Proposer都可能失效，独占锁机制下获得独占锁定权的Proposer失效会导致死锁</p>
</li>
<li><p>提案编号由Proposer自己维护，一般采用递增机制且全局唯一。<br>这样就可以对提案进行全局排序，只有提案编号高的(最新)的提案被接受，避免了死锁</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>文章</strong></p>
<ul>
<li><p><a href="https://www.jianshu.com/p/ddf0db5d5f52" target="_blank" rel="noopener">https://www.jianshu.com/p/ddf0db5d5f52</a></p>
</li>
<li><p><a href="https://www.chainnode.com/post/220369" target="_blank" rel="noopener">https://www.chainnode.com/post/220369</a></p>
</li>
</ul>
<h3 id="raft">raft<a class="post-anchor" href="#raft"></a></h3><p><strong>定义</strong></p>
<ul>
<li><p>raft是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。在这里强调了是在工程上，因为在学术理论界，最耀眼的还是大名鼎鼎的Paxos。<br>但Paxos是：少数真正理解的人觉得简单，尚未理解的人觉得很难，大多数人都是一知半解。<br>本人也花了很多时间、看了很多材料也没有真正理解。直到看到raft的论文，两位研究者也提到，他们也花了很长的时间来理解Paxos，他们也觉得很难理解，于是研究出了raft算法。</p>
</li>
<li><p>raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下。<br>这些年最为火热的加密货币（比特币、区块链）就需要共识算法，而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），<br>在带着问题学习分布式系统之中心化复制集一文中介绍了中心化复制集的相关知识。<br>raft协议就是一种leader-based的共识算法，与之相应的是leaderless的共识算法。</p>
</li>
<li><p>Raft算法的头号目标就是容易理解（UnderStandable），这从论文的标题就可以看出来。<br>当然，Raft增强了可理解性，在性能、可靠性、可用性方面是不输于Paxos的。</p>
<ul>
<li><p>Raft more understandable than Paxos and also provides a better foundation for building practical systems</p>
</li>
<li><p>为了达到易于理解的目标，raft做了很多努力，其中最主要是两件事情：</p>
<ul>
<li><p>问题分解</p>
</li>
<li><p>状态简化</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>问题分解是将”复制集中节点一致性”这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。<br>在raft，子问题包括，leader election， log replication，safety，membership changes。<br>而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性<br>（比如，保证新选举出来的leader会包含所有commited log entry）</p>
</li>
<li><p>Raft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for managing the replicated log.<br>The leader accepts log entries from clients,replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines.<br>A leader can fail or become disconnected from the other servers, in which case a new leader is elected.</p>
</li>
<li><p>上面的引文对raft协议的工作原理进行了高度的概括：<br>raft会先选举出leader，leader完全负责replicated log的管理。<br>leader负责接受所有客户端更新请求，然后复制到follower节点，并在“安全”的时候执行这些请求。<br>如果leader故障，followes会重新选举出新的leader。</p>
</li>
<li><p>Raft 通过远程过程调用(RPC)来实现节点间的通信, 定义了下面几种 RPC:</p>
<ul>
<li><p>RequestVote RPC: 由 candidate 调用, 用于进行 leader 选举.</p>
</li>
<li><p>AppendEntries RPC: 由 leader 调用, 用于复制日志或作为心跳信息(维持leader).</p>
</li>
</ul>
</li>
</ul>
<p><strong>这就涉及到raft最新的两个子问题</strong></p>
<ul>
<li><p>leader election</p>
<ul>
<li><p>相关概念</p>
<ul>
<li><p>term</p>
<ul>
<li><p>任期</p>
<ul>
<li><p>从上面可以看出，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。<br>这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫term。</p>
</li>
<li><p>……</p>
</li>
<li><p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。<br>从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；<br>另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>选举过程详解</p>
<ul>
<li><p>上面已经说过，如果follower在election timeout内没有收到来自leader的心跳，<br>（<br>也许此时还没有选出leader，大家都在等；<br>也许leader挂了；<br>也许只是leader与该follower之间网络故障<br>）<br>，则会主动发起选举。</p>
</li>
<li><p>步骤如下：</p>
<ul>
<li><p>增加节点本地的 current term ，切换到candidate状态</p>
</li>
<li><p>投自己一票</p>
</li>
<li><p>并行给其他节点发送 RequestVote RPCs</p>
</li>
<li><p>等待其他节点的回复</p>
</li>
</ul>
</li>
<li><p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p>
<ul>
<li><p>收到majority的投票（含自己的一票），则赢得选举，成为leader</p>
<ul>
<li><p>第一种情况，赢得了选举之后，新的leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。<br>在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：</p>
<ul>
<li><p>在任一任期内，单个节点最多只能投一票</p>
</li>
<li><p>候选人知道的信息不能比自己的少<br>（这一部分，后面介绍log replication和safety的时候会详细介绍）</p>
</li>
<li><p>first-come-first-served 先来先得</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>被告知别人已当选，那么自行切换到follower</p>
<ul>
<li>第二种情况，比如有三个节点A B C。<br>A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。<br>A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。</li>
</ul>
</li>
<li><p>一段时间内没有收到majority投票，则保持candidate状态，重新发出选举</p>
<ul>
<li><p>第三种情况，没有任何节点获得majority投票，比如下图这种情况：</p>
</li>
<li><p>……</p>
</li>
<li><p>总共有四个节点，Node C、Node D同时成为了candidate，进入了term 4，但Node A投了NodeD一票，NodeB投了Node C一票，这就出现了平票 split vote的情况。<br>这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间（没有leader是不能处理客户端写请求的），<br>因此raft引入了randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>log replication</p>
<ul>
<li><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤：</p>
</li>
<li><p>请求完整流程</p>
<ul>
<li><p>leader append log entry</p>
</li>
<li><p>leader issue AppendEntries RPC in parallel</p>
</li>
<li><p>leader wait for majority response</p>
</li>
<li><p>leader apply entry to state machine</p>
</li>
<li><p>leader reply to client</p>
</li>
<li><p>leader notify follower apply log</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>性质</strong></p>
<ul>
<li><p>Election Safety:</p>
<ul>
<li>最多只有一个节点成为 Leader.</li>
</ul>
</li>
<li><p>Leader Append-Only:</p>
<ul>
<li>Leader 不会删除或覆盖自身的日志, 只会不断将新的日志附加到日志末尾.</li>
</ul>
</li>
<li><p>Log Matching:</p>
<ul>
<li>如果两条日志(log entry)的term和index相同, 那么从这两条日志开始, 她们和她们前面的所有日志都对应相同.</li>
</ul>
</li>
<li><p>Leader Completeness:</p>
<ul>
<li>如果一条日志在一个 term 中被 commit 了,<br>那么在该 term 之后的所有 term 中, 这些 term 的 Leader 的日志中都包含这条日志.</li>
</ul>
</li>
<li><p>State Machine Safety:</p>
<ul>
<li>如果一个节点应用了一条日志到状态机, 那么其他机器不会应用一个 index 与此日志相同, 内容却不同的日志到状态机.<br>也就是说, 对于不同节点应用到状态机的日志, 只要 index 相同, 日志就是相同的.</li>
</ul>
</li>
</ul>
<h3 id="POA">POA<a class="post-anchor" href="#POA"></a></h3><p><strong>定义</strong></p>
<ul>
<li><p>POA(Proof of Activity)</p>
<ul>
<li>行动证明</li>
</ul>
</li>
<li><p>链上节点相互信任</p>
</li>
<li><p>授权证明（PoA）是PoS一致性算法的子集，主要由测试网和私有或联盟网络使用。<br>在基于PoA的区块链中，交易有效性最终由一组经批准的链上账户确定，称为“授权节点”。<br>确定授权节点的标准是通过网络治理结构中编写的方法确定性地决定的。</p>
</li>
<li><p>PoA被广泛认为是达成共识的最快途径，但依赖于验证节点尚未受到损害的假设。<br>非验证参与者可以像公共以太网那样访问和使用网络（通过利用p2p交易，合约，账户等）</p>
</li>
<li><p>PoA共识依赖于验证者的声誉和过去的表现。这个想法是验证者节点将其身份/声誉放到我的身上。<br>私人联盟网络的一个重要方面是链上地址与已知的现实世界身份之间的联系。<br>因此，我们可以说验证节点正在盯着他们的“身份”或“声誉”（而不是他们的经济持有）。<br>这为验证者创建了一定程度的问责制，最适合企业，私有或测试网络。</p>
</li>
<li><p>PoA目前由测试网络Kovan（PoA网络）使用，并且可以在Parity中轻松配置用于私人联盟网络。</p>
</li>
<li><p>Combine Proof of Work component with a Proof of Stake.</p>
</li>
<li><p>mining first begins in the traditional manner, with miners vying to be the first to solve a puzzle and claim their reward.<br>The difference is that the blocks being mined do not contain transactions.<br>They are simply templates with header information and the mining reward address.<br>Once this nearly blank block is mined, the system switches to a proof of stake protocol.<br>The header information is used to select a random group of validators to sign the block.<br>These are coin holders (stakeholders) and the larger the stake a validator holds, the greater the chance they will be selected to sign the new block.<br>Once all the chosen validators sign the block it becomes an actual part of the blockchain.<br>If the block remains unsigned by some of the chosen validators after a given time, it is discarded as incomplete and the next winning block is used.<br>Validators are once again chosen and this continues until a winning block is signed by all the chosen validators.<br>The network fees are split between the winning miner and the validators who signed the block.</p>
</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>POA – 共产主义</li>
</ul>
<h2 id="其他">其他<a class="post-anchor" href="#其他"></a></h2><h3 id="ripple">ripple<a class="post-anchor" href="#ripple"></a></h3><p><strong>瑞波币</strong></p>
<p>小蚁共识</p>
<h1 id="总结"><strong>总结</strong><a class="post-anchor" href="#总结"></a></h1><p>每一种共识机制都不能同时满足安全、效率、公平。 去中心程度越弱，安全性就越低，区块链的速度就越快； 去中心化程度越强，安全性就会越高，区块链的速度就会越慢。</p>
<p>POW完全去中心化，但运行效率太低。 POS提高了效率，但却降低了公平与安全。 DPOS有强烈的中心化特性，却在短期内效率最高。</p>
<p>目前行业区块链大范围使用Pool共识。</p>
<h1 id="其他-1"><strong>其他</strong><a class="post-anchor" href="#其他-1"></a></h1><h2 id="问题与挑战">问题与挑战<a class="post-anchor" href="#问题与挑战"></a></h2><ol>
<li><p>如何提出一个待共识的提案？如通过令牌传递、随机选取、权重比较、求解难题…</p>
</li>
<li><p>如何让多个节点对该提案达成共识（同意或拒绝），如投票、规则验证…</p>
</li>
</ol>
<p>故障节点：非拜占庭节点 恶意节点：拜占庭节点 非拜占庭场景的典型例子是通过报数来统计人数，即便偶有冲突（如两人同时报一个数）也能很快解决； 拜占庭场景的一个常见例子是“杀人游戏”，当参与者众多时很难快速达成共识。</p>
<h2 id="共识机制（数据同步）">共识机制（数据同步）<a class="post-anchor" href="#共识机制（数据同步）"></a></h2><h3 id="特性">特性<a class="post-anchor" href="#特性"></a></h3><p><strong>少部分写，多读</strong></p>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
        <category>导图</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链的种类</title>
    <url>/2022/02121133/</url>
    <content><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><!-- TODO:实现搜索框的按键展示(使用页面缩放?或者是弹性相应和直接style) -->

<div class="post-mindmap">
  <iframe class="mindmap" id="mindmap" src="区块链 - 分类.html"></iframe>
  <div class="r">
  <span class="iconfont icon-close"></span>
    <div class="tip"></div>
    <a class="fullscreen-button">Full Screen</a>
</div>
</div>
  <script type="text/javascript">
    var sonWidth = document.getElementById("mindmap").offsetWidth;
    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";
</script>




<h1 id="概述"><strong>概述</strong><a class="post-anchor" href="#概述"></a></h1><p>……</p>
<h1 id="按应用范围"><strong>按应用范围</strong><a class="post-anchor" href="#按应用范围"></a></h1><h2 id="公有链">公有链<a class="post-anchor" href="#公有链"></a></h2><h3 id="概念">概念<a class="post-anchor" href="#概念"></a></h3><p><strong>公链（public blockchain）</strong></p>
<ul>
<li><p>公有区块链</p>
</li>
<li><p>公有（Public）链</p>
</li>
</ul>
<p><strong>世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。</strong></p>
<p><strong>公链，是指全世界任何人都可读取、发送交易且能获得有效确认的共识区块链。公链的安全由工作量证明机制（pow）或权益证明机制(pos)等方式负责维护。 它们是以经济奖励与加密数字验证相结合的方式而存在的，并遵循着一般原则：每个人从中可获得的经济奖励，与对共识过程作出的贡献成正比。 这些区块链通常被认为是“完全去中心化”的</strong></p>
<p><strong>公有区块链是最早的区块链，也是应用最广泛的区块链， 各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上有且仅有一条该币种对应的区块链。</strong></p>
<h3 id="特点">特点<a class="post-anchor" href="#特点"></a></h3><p><strong>所有人可以随时自带的加入和退出，每个节点平等，都有权交易和记账，属于开放式</strong></p>
<h3 id="代表">代表<a class="post-anchor" href="#代表"></a></h3><p><strong>比特币</strong></p>
<ul>
<li>Bitcoin</li>
</ul>
<p><strong>以太坊</strong></p>
<ul>
<li>Ethereum</li>
</ul>
<p><strong>EOS</strong></p>
<p><strong>NEO</strong></p>
<p><strong>量子链</strong></p>
<p><strong>比原链</strong></p>
<p><strong>井通链</strong></p>
<p><strong>Hyperledger</strong></p>
<p><strong>TRON</strong></p>
<h2 id="联盟链">联盟链<a class="post-anchor" href="#联盟链"></a></h2><h3 id="概述-1">概述<a class="post-anchor" href="#概述-1"></a></h3><p><strong>联盟（Consortium）链</strong></p>
<ul>
<li><p>联合（行业）区块链</p>
</li>
<li><p>共同体区块链 （Consortium blockchains）</p>
</li>
</ul>
<p><strong>由某个群体内部指定多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程）， 其他接入节点可以参与交易，但不过问记账过程 (本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点）， 其他任何人可以通过该区块链开放的API进行限定查询；</strong></p>
<p><strong>我们在前面的文章介绍过它。所谓联盟链，就是这个区块链具有准入许可，不像公链，任何人都可以随时进入。<br>准入许可也就意味着候选节点进入区块链时需要得到已经在网络中的节点许可，所以联盟链也叫做许可链。</strong></p>
<p><strong>共同体区块链，是指其共识过程受到预选节点控制的区块链；</strong></p>
<ul>
<li>例如，有15个金融机构组成一个共同体，每个机构都运行着一个节点，而且为了使每个区块生效需要获得其中10个机构的确认。 区块链或许允许每个人都可读取，或者只受限于参与者，或走混合型的路线， 例如区块的根哈希及其API（应用程序接口）对外公开，API可允许外界用来作有限次数的查询和获取区块链状态的信息。 这些区块链可视为“部分去中心化”</li>
</ul>
<h3 id="特点-1">特点<a class="post-anchor" href="#特点-1"></a></h3><p><strong>仅部分人参与，加入和退出需要授权，选定某些节点为记账人，其他人可以交易，但无记账权，属于半封闭式</strong></p>
<h3 id="代表-1">代表<a class="post-anchor" href="#代表-1"></a></h3><p><strong>R3CEV，全球40多个银行成立的联盟组织，2017年7月成立，共享区块链技术</strong></p>
<p><strong>IBM fabric项目</strong></p>
<ul>
<li>超级账本Fabric</li>
</ul>
<p><strong>Linux基金会发起的超级账本(HyperLedger)项目，2015年成立，fabric是子项目</strong></p>
<p><strong>如银行联盟，搭建转账系统</strong></p>
<h2 id="私有链">私有链<a class="post-anchor" href="#私有链"></a></h2><h3 id="概述-2">概述<a class="post-anchor" href="#概述-2"></a></h3><p><strong>私有（Private）链</strong></p>
<ul>
<li><p>私有区块链</p>
</li>
<li><p>私链（private blockchain)，又称无代币区块链（Token-less blockchain）</p>
</li>
</ul>
<p><strong>如果是私有的，有比区块链成本更低的解决方案</strong></p>
<p><strong>完全私有的区块链 , 是指其写入权限仅在一个组织手里的区块链。<br>读取权限或者对外开放，或者被任意程度地进行了限制。<br>相关的应用囊括数据库管理、审计、甚至一个公司，但在很多的情形下，公共的可读性并非是必须的。</strong></p>
<p><strong>关于没有原生代币的系统，是否能被称为区块链，仍然有着很大的争议。<br>一些人认为，没有代币的区块链，可以一种分布式多版本并发控制(MVCC)数据库的形式而存在。<br>多版本并发控制，可防止两笔交易在数据库中修改一个单一列，而区块链，则是阻止两笔交易在区块链中的单个输出（ output）。</strong></p>
<h3 id="特点-2">特点<a class="post-anchor" href="#特点-2"></a></h3><p><strong>公司内部使用，可以更好的实现权限控制：管理和审计，属于封闭式</strong></p>
<h3 id="代表-2">代表<a class="post-anchor" href="#代表-2"></a></h3><p><strong>如企业内部链</strong></p>
<h1 id="按部署机制"><strong>按部署机制</strong><a class="post-anchor" href="#按部署机制"></a></h1><h2 id="主链">主链<a class="post-anchor" href="#主链"></a></h2><p>主网</p>
<h2 id="测试链">测试链<a class="post-anchor" href="#测试链"></a></h2><p>测试网</p>
<h1 id="按对接类型"><strong>按对接类型</strong><a class="post-anchor" href="#按对接类型"></a></h1><h2 id="侧链">侧链<a class="post-anchor" href="#侧链"></a></h2><h3 id="概述-3">概述<a class="post-anchor" href="#概述-3"></a></h3><p><strong>如闪电网络，用于解决比特币区块链确认过久的问题</strong></p>
<p><strong>侧链是一种双向挂钩技术，将主链中的代币锁定到側链中使用。<br>所以可以将主链看作主干道，侧链看作与主链相对独立的一条分支道，作为主链功能的低耦合拓展</strong></p>
<h3 id="如何实现">如何实现<a class="post-anchor" href="#如何实现"></a></h3><p><strong>公证人机制（Notary schemes）</strong></p>
<ul>
<li><p>第一种是有一组同时承担两条链节点的个人或联盟，也有可能是一条单独的链，告诉 B 链 A 链上发生什么事，或者告诉 B 某个消息的真的。<br>比如 Ripple 开发的跨账本价值传输开放协议 Interledger，但它不是链，只是一套网关协议。V 神把这种称为公证人模式（Notary schemes）。</p>
</li>
<li><p>公证人机制（Notary schemes）：三种方式中最为简单，目前使用的也是比较多的一种方式，举下例子：PBFT协议中，每个节点都是一个公证人，那么你从节点中获得超过三分之二的节点签名，那么就表示这个公证是有效的。<br>或者，在实现锚锭侧链的时候，主链发送交易到侧链时候所拥有的一个多重签名地址，然后需要花费这个交易的时候必须同时提供8-of-10的multisig的签名才是有效。现在使用公证技术的有：字节雪球的witness、ZCASH的6参数生成过程，rootstacke中的semi-trust-free-sidechains（公证方案）。这种方式优点就是简单，整个过程就是对公证节点的信任，缺点就是你需要去信任一或多个实体节点。</p>
</li>
</ul>
<p><strong>侧链/中继（Sidechains/relays）</strong></p>
<ul>
<li><p>另一种则是侧链 / 中继（Sidechains/relays），与公证人模式的 “别人告诉 B 链 A 链上发生的事” 不同，中继模式则是更 “直接” 地 B 链自己读 A 链。<br>比如通过验证 A 链区块头和默克尔树等信息验证 A 链上的交易，比如以太坊上的 BTC Relay</p>
</li>
<li><p>有些人把这个两个技术分开来说明，这里就放一块解释了。<br>首先有个概念普及下，主链是不知道侧链的存在，侧链则知道主链的存在（其实这个是废话，不知道他怎么做侧链），<br>侧链的概念就是一个链能去读懂另外一个链，用白皮书的定义：sidechain is a blockchain that validates data from other blockchains。</p>
</li>
<li><p>侧链存在的条件，一般来说主链通常支持SPV（参考笔者前文比特币架构），主链向侧链提供SPV proof来验证主链中发生的事件（这个事件理解为区块的产生，交易的生成等一系列主链状态的变化）。<br>侧链其实是以锚定比特币为基础的新型区块链，以融合的方式实现加密货币金融生态的目标，而不是像其它加密货币一样排斥现有的系统。</p>
</li>
<li><p>中继技术，在A.B两个链中，存在第三方数据结构C，那么这个C就是A和B的中继，如果C也是区块链结构，那么就称relay-chain。<br>举个例子：著名的比特币侧链BTC Relay，一种基于以太坊的智能合约，将以太坊和比特币网络以一种安全去中心化的方式连接起来。</p>
</li>
</ul>
<p><strong>哈希锁定（Hash-locking）</strong></p>
<ul>
<li>哈希锁定，也叫原子互换（Atomic Swap），主要是通过哈希时间锁（hash time lock）和密数（Secret）让双方完成交易，不需要第三方公证人。</li>
</ul>
<p>互联链</p>
<h1 id="按共识算法分类"><strong>按共识算法分类</strong><a class="post-anchor" href="#按共识算法分类"></a></h1><p>见共识算法</p>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
        <category>导图</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>IPFS简单教程</title>
    <url>/2022/01291902/</url>
    <content><![CDATA[<html><head></head><body><h2 id="安装">安装<a class="post-anchor" href="#安装"></a></h2><ul>
<li><p><a href="https://docs.ipfs.io/install/ipfs-desktop/#install-instructions" target="_blank" rel="noopener">桌面版</a></p>
</li>
<li><p><a href="https://dist.ipfs.io/#go-ipfs" target="_blank" rel="noopener">命令行</a></p>
</li>
</ul>
<h3 id="命令行安装">命令行安装<a class="post-anchor" href="#命令行安装"></a></h3><p><a href="https://docs.ipfs.io/install/command-line/#linux" target="_blank" rel="noopener">https://docs.ipfs.io/install/command-line/#linux</a></p>
<h3 id="命令行初始化">命令行初始化<a class="post-anchor" href="#命令行初始化"></a></h3><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 以64bit为例(先参见上述安装命令进行安装)</span><br><br><span class="hljs-comment"># 在~目录下创建结点.ipfs目录</span><br>ipfs init<br><span class="hljs-comment"># 开启服务守护进程</span><br>ipfs daemon<br></code></pre></td></tr></tbody></table></figure>

<h2 id="网关">网关<a class="post-anchor" href="#网关"></a></h2><h3 id="WebUI">WebUI<a class="post-anchor" href="#WebUI"></a></h3><p><a href="http://127.0.0.1:5001/webui" target="_blank" rel="noopener">http://127.0.0.1:5001/webui</a></p>
<h3 id="Gateway-网关">Gateway 网关<a class="post-anchor" href="#Gateway-网关"></a></h3><p><a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a></p>
<h3 id="HTTP-API">HTTP API<a class="post-anchor" href="#HTTP-API"></a></h3><p><a href="http://127.0.0.1:5001" target="_blank" rel="noopener">http://127.0.0.1:5001</a></p>
<h3 id="向外网开放-WebUI，Gateway-或-HTTP-API">向外网开放 WebUI，Gateway 或 HTTP API<a class="post-anchor" href="#向外网开放-WebUI，Gateway-或-HTTP-API"></a></h3><ul>
<li>更改设置，将目标项的地址由 <strong>127.0.0.1</strong> 更改为 <strong>0.0.0.0</strong></li>
<li>开放 WebUI 和 HTTP API，更改<strong>API</strong></li>
<li>开放网关，更改<strong>Gateway</strong><blockquote>
<ul>
<li>通过图形界面<br><a href="images/desktop-config.png" data-caption="通过图形界面" data-fancybox="images"><img src="images/desktop-config.png" alt="通过图形界面"></a></li>
<li>对于命令行，更改用户目录下~/.ipfs/config，或运行</li>
</ul>
<figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> EDITOR=/usr/bin/vim<br>ipfs config edit<br></code></pre></td></tr></tbody></table></figure>
</blockquote>
</li>
</ul>
<h2 id="文件添加">文件添加<a class="post-anchor" href="#文件添加"></a></h2><h3 id="命令行">命令行<a class="post-anchor" href="#命令行"></a></h3><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">"test command line"</span> &gt; command.txt<br>ipfs add command.txt<br><span class="hljs-comment"># 返回 added QmXWrM5PCU1jcZ6xBoLxZ2uXxuWmBRdoJcoe9pNP4yGBKa command.txt</span><br>ipfs cat QmXWrM5PCU1jcZ6xBoLxZ2uXxuWmBRdoJcoe9pNP4yGBKa<br><span class="hljs-comment"># 返回 test command line</span><br></code></pre></td></tr></tbody></table></figure>

<h3 id="POSTMAN">POSTMAN<a class="post-anchor" href="#POSTMAN"></a></h3><ol>
<li><p>在<strong>C:\Users\&lt;你的用户名&gt;\Postman\files</strong>下创建<strong>postman.txt</strong>，写入 test postman</p>
</li>
<li><p>在表单中选择 postman 文件目录下的文件，参数设为 file</p>
</li>
<li><p>点击<strong>Send</strong></p>
</li>
</ol>
<p><a href="images/postman.png" data-caption="postman" data-fancybox="images"><img src="images/postman.png" alt="postman"></a></p>
<h3 id="JAVA-demo">JAVA demo<a class="post-anchor" href="#JAVA-demo"></a></h3><p><a href="ipfs-demo/src/main/java/com/hncfx/api/ADD.java">以 okhttp 为例</a></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java">RequestBody body = <span class="hljs-keyword">new</span> MultipartBody.Builder().setType(MultipartBody.FORM)<br>                <span class="hljs-comment">// 使用file为表单键上传文件</span><br>                .addFormDataPart(<span class="hljs-string">"file"</span>, file.getName(), filebody)<br>                .build();<br>Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>                .url(<span class="hljs-string">"http://127.0.0.1:5001/api/v0/add"</span>)<br>                .method(<span class="hljs-string">"POST"</span>, body)<br>                .build();<br>Response response = client.newCall(request).execute();<br></code></pre></td></tr></tbody></table></figure>

<h2 id="文件查看">文件查看<a class="post-anchor" href="#文件查看"></a></h2><ul>
<li>desktop 上通过 qmhash 查看<br><a href="images/desktop-view.png" data-caption="qmhash" data-fancybox="images"><img src="images/desktop-view.png" alt="qmhash"></a></li>
<li><a href="https://ipfs.io/ipfs/QmQ9t2hmjjfBgDYvvTmBu2aDt6ZeVWDKLnMtP3ic6RWSDz" target="_blank" rel="noopener">通过网关访问</a><blockquote>
<p><a href="https://ipfs.github.io/public-gateway-checker/" target="_blank" rel="noopener">公共网关</a></p>
</blockquote>
</li>
</ul>
<h2 id="常用命令">常用命令<a class="post-anchor" href="#常用命令"></a></h2><ul>
<li><p><strong>ipfs add</strong> 添加文件</p>
</li>
<li><p><strong>ipfs cat</strong> 打印文件</p>
</li>
<li><p><strong>ipfs config show</strong> 显示设置</p>
</li>
<li><p><strong>ipfs pin ls</strong> 显示本地持久化文档(通过 add 添加的默认为本地持久化的)</p>
</li>
</ul>
<h2 id="参考">参考<a class="post-anchor" href="#参考"></a></h2><p><a href="https://www.jianshu.com/p/48a2739bade2" target="_blank" rel="noopener">IPFS 开发简介与入门实战 - 简书</a></p>
<p><a href="https://github.com/miaoski/ipfs-tutorial" target="_blank" rel="noopener">miaoski/ipfs-tutorial: IPFS 筆記和教學 (繁體中文)</a></p>
<p><a href="https://docs.ipfs.io/" target="_blank" rel="noopener">IPFS Documentation | IPFS Docs</a></p>
<p><a href="http://cw.hubwiz.com/card/c/ipfs/1/1/1/" target="_blank" rel="noopener">ipfs命令手册</a></p>
</body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的一般使用流程图</title>
    <url>/2020/03302317/</url>
    <content><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><!-- TODO:实现搜索框的按键展示(使用页面缩放?或者是弹性相应和直接style) -->

<div class="post-mindmap">
  <iframe class="mindmap" id="mindmap" src="git的一般使用流程图.html"></iframe>
  <div class="r">
  <span class="iconfont icon-close"></span>
    <div class="tip"></div>
    <a class="fullscreen-button">Full Screen</a>
</div>
</div>
  <script type="text/javascript">
    var sonWidth = document.getElementById("mindmap").offsetWidth;
    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";
</script>


<!--
 * @Author: tako star
 * @Date: 2020-03-30 23:17:38
 * @LastEditors: tako star
 * @LastEditTime: 2020-04-16 16:51:03
 -->
</body></html>]]></content>
      <categories>
        <category>笔记</category>
        <category>导图</category>
      </categories>
  </entry>
  <entry>
    <title>Github仓库搜索技巧介绍</title>
    <url>/2020/02041547/</url>
    <content><![CDATA[<html><head></head><body><h2 id="搜索关键词">搜索关键词<a class="post-anchor" href="#搜索关键词"></a></h2><h3 id="in-name-keyword">in:name keyword<a class="post-anchor" href="#in-name-keyword"></a></h3><blockquote>
<p>如 <code>in:name spring boot</code></p>
</blockquote>
<ul>
<li>用上述方法可以迅速的找到自己想要的 github 项目<br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/mindmap.png" data-caption="在项目描述中寻找关键词" 思维导图".png"="" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/mindmap.png" alt="在项目描述中寻找关键词" 思维导图".png"=""></a><br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/note.png" data-caption="迅速寻找笔记.png" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/note.png" alt="迅速寻找笔记.png"></a></li>
</ul>
<h4 id="其他关键词搜索目标">其他关键词搜索目标<a class="post-anchor" href="#其他关键词搜索目标"></a></h4><ul>
<li>readme</li>
<li>description</li>
<li>……</li>
</ul>
<h2 id="项目筛选方式">项目筛选方式<a class="post-anchor" href="#项目筛选方式"></a></h2><ul>
<li>star</li>
</ul>
<blockquote>
<p>如<code>stars:&gt;300</code></p>
</blockquote>
<ul>
<li>language</li>
</ul>
<blockquote>
<p>如<code>language:java</code></p>
</blockquote>
<ul>
<li>fork</li>
</ul>
<blockquote>
<p>如<code>fork:&gt;300</code></p>
</blockquote>
<ul>
<li>pushed</li>
</ul>
<blockquote>
<p>如<code>pushed:&gt;2019-2-3</code></p>
</blockquote>
<ul>
<li>……</li>
</ul>
<h2 id="更多搜索技巧和范围">更多搜索技巧和范围<a class="post-anchor" href="#更多搜索技巧和范围"></a></h2><ul>
<li><p>不同筛选条件用空格间隔并列</p>
</li>
<li><p>更加详细的搜索方法可以在<a href="https://help.github.com/cn/github/searching-for-information-on-github/searching-on-github" target="_blank" rel="noopener">github 的官方使用帮助</a>上搜索获取更多种类的搜索方式<br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/doc.png" data-caption="image.png" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/doc.png" alt="image.png"></a></p>
<p> 如根据帮助文档描述寻找住在北京的 github 用户：</p>
<blockquote>
<p><code>location:beijing</code><br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/location.png" data-caption="image.png" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/location.png" alt="image.png"></a></p>
</blockquote>
</li>
</ul>
<!--
 * @Author: tako star
 * @Date: 2020-02-04 15:47:05
 * @LastEditors: tako star
 * @LastEditTime: 2020-04-06 19:44:44
 -->
</body></html>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客建立成功！</title>
    <url>/2020/01301130/</url>
    <content><![CDATA[<html><head></head><body><h2 id="博客建立成功">博客建立成功<a class="post-anchor" href="#博客建立成功"></a></h2><hr>
<ul>
<li>基于 hexo 建立的博客，使用了 github 的托管,其中 hexo 的主题为<a href="https://github.com/shixiaohu2206/hexo-theme-huhu" target="_blank" rel="noopener">hexo-theme-huhu</a></li>
<li>教程参考于 codesheep 的<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">博客搭建教程</a></li>
<li>本博客将用于整理分享的学习经验和总结</li>
</ul>
<p>​ ——TakoStar</p>
<h2 id="建立博客的经验">建立博客的经验<a class="post-anchor" href="#建立博客的经验"></a></h2><h3 id="搭建">搭建<a class="post-anchor" href="#搭建"></a></h3><p>codesheep 的<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">博客搭建教程</a></p>
<h3 id="完善">完善<a class="post-anchor" href="#完善"></a></h3><ul>
<li>评论</li>
<li>百度统计</li>
</ul>
<h3 id="SEO">SEO<a class="post-anchor" href="#SEO"></a></h3><ul>
<li>域名</li>
<li>证书</li>
<li>备案</li>
<li>百度、谷歌收录</li>
</ul>
<h2 id="我对博客的看法">我对博客的看法<a class="post-anchor" href="#我对博客的看法"></a></h2><ol>
<li>为什么写博客</li>
<li>如何写博客</li>
</ol>
<h2 id="关于我">关于我<a class="post-anchor" href="#关于我"></a></h2><ul>
<li>男，ACGN 爱好者</li>
<li>以一个合格的程序员为目标努力中<br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/01301130/12218320_p0.jpg" data-caption="秋庭里香——仰望半月的夜空.jpg" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/01301130/12218320_p0.jpg" alt="秋庭里香——仰望半月的夜空.jpg"></a></li>
</ul>
<h2 id="站点记录">站点记录<a class="post-anchor" href="#站点记录"></a></h2><p>本站于 <code class="site_from"></code> 接入百度站点，建站已 <code class="site_date"></code> 天</p>
<!-- 截止到目前，整站访问次数 <code class="site_pv"></code>、访问人数 <code class="site_uv"></code> -->

<!--
 * @Author: tako star
 * @Date: 2020-01-30 11:30:02
 * @LastEditors: tako star
 * @LastEditTime: 2020-04-16 15:50:52
 -->
</body></html>]]></content>
      <categories>
        <category>关键活动</category>
      </categories>
      <tags>
        <tag>梦呓</tag>
      </tags>
  </entry>
</search>
