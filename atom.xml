<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TakoStar&#39;s yosora</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://takostar.net/"/>
  <updated>2022-03-19T14:18:09.165Z</updated>
  <id>http://takostar.net/</id>
  
  <author>
    <name>Tako</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式场景下的CAP理论BASE理论和事务中的ACID特性</title>
    <link href="http://takostar.net/2022/03192214/"/>
    <id>http://takostar.net/2022/03192214/</id>
    <published>2022-03-19T14:14:30.000Z</published>
    <updated>2022-03-19T14:18:09.165Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><!-- TODO:实现搜索框的按键展示(使用页面缩放?或者是弹性相应和直接style) --><div class="post-mindmap">  <iframe class="mindmap" id="mindmap" src="CAP-BASE-ACID.html"></iframe>  <div class="r">  <span class="iconfont icon-close"></span>    <div class="tip"></div>    <a class="fullscreen-button">Full Screen</a></div></div>  <script type="text/javascript">    var sonWidth = document.getElementById("mindmap").offsetWidth;    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";</script><h1 id="CAP"><strong>CAP</strong><a class="post-anchor" href="#CAP"></a></h1><h2 id="历史">历史<a class="post-anchor" href="#历史"></a></h2><p>「CAP」理论由Eric Brewer在2000年PODC会议上提出</p><p>是Eric Brewer在Inktomi期间研发搜索引擎、分布式web缓存时得出的一个猜想</p><p>后来Seth Gilbert和Nancy Lynch对其进行了证明</p><h2 id="概述">概述<a class="post-anchor" href="#概述"></a></h2><h3 id="版本">版本<a class="post-anchor" href="#版本"></a></h3><p><strong>第一版解释</strong></p><ul><li>对于一个分布式计算系统，不可能同时满足一致性、可用性、分区容错性三个设计约束</li></ul><p><strong>第二版解释</strong></p><ul><li>在一个分布式系统中，当涉及读写操作时，只能保证一致性、可用性、分区容错性三者中的二个，另一个必须被牺牲</li></ul><p><strong>二个版本差异点</strong></p><ul><li><p>分布式：连接并共享数据。分布式系统并不一定会互联和共享数据，比如：Memcache 不符合 CAP 理论，Mysql 符合</p></li><li><p>CAP 关注的是对数据的读写操作，而不是分布式系统的所有功能。<br>比如 ZK 的选举机制就不是 CAP 探讨的对象</p></li></ul><p>三个要素只能实现两点，不能兼顾</p><p>一个分布式系统不可能满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个。</p><p>CAP理论断言任何基于网络的数据共享系统，<br>最多只能满足数据一致性、可用性、分区容忍性三要素中的两个要素。<br>但是通过显式处理分区情形，系统设计师可以做到优化数据一致性和可用性，进而取得三者之间的平衡。</p><h3 id="分布式系统在设计时只能满足两种，无法兼顾三种。">分布式系统在设计时只能满足两种，无法兼顾三种。<a class="post-anchor" href="#分布式系统在设计时只能满足两种，无法兼顾三种。"></a></h3><p><strong>一个分布式系统里面，节点组成的网络本来应该是连通的。<br>然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。<br>当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。<br>提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。<br>然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。<br>要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。<br>总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。<br>为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。</strong></p><p>对大型网站，可用性与分区容忍性优先级要高于数据一致性，<br>一般会尽量朝着 A、P 的方向设计，然后通过其它手段保证对于一致性的商务需求。</p><h3 id="CAP定理（布鲁尔定理）">CAP定理（布鲁尔定理）<a class="post-anchor" href="#CAP定理（布鲁尔定理）"></a></h3><p><strong>又被称作布鲁尔定理（Brewer’s theorem）</strong></p><p>C、A、P三者最多只能满足其中两个，和FLP定理一样，CAP定理也指示了一个不可达的结果（impossibility result）</p><h3 id="对于分布式系统工程实践，CAP理论更适合描述：在满足分区容错的前提下，没有算法能同时满足数据一致性和服务可用性。">对于分布式系统工程实践，CAP理论更适合描述：在满足分区容错的前提下，没有算法能同时满足数据一致性和服务可用性。<a class="post-anchor" href="#对于分布式系统工程实践，CAP理论更适合描述：在满足分区容错的前提下，没有算法能同时满足数据一致性和服务可用性。"></a></h3><p><strong>In a network subject to communication failures,<br>it is impossible for any web service to implement an atomic read/write shared memory that guarantees a response to every request.</strong></p><h3 id="分布式系统无法同时确保一致性、可用性和分区容忍性，设计中往往需要弱化对某个特性的需求。分布式系统最多只能保证其中的两项特性。">分布式系统无法同时确保一致性、可用性和分区容忍性，设计中往往需要弱化对某个特性的需求。分布式系统最多只能保证其中的两项特性。<a class="post-anchor" href="#分布式系统无法同时确保一致性、可用性和分区容忍性，设计中往往需要弱化对某个特性的需求。分布式系统最多只能保证其中的两项特性。"></a></h3><p><strong>例如</strong></p><ul><li><p>网络出现分区时，系统无法同时保证一致性和可用性。</p></li><li><p>要么，节点因没有得到其他节点的确认而不应答（牺牲可用性）；</p></li><li><p>要么，节点只能应答非一致的结果（牺牲一致性）</p></li></ul><h3 id="一个分布式系统只能满足-一致性-可用性-分区容错性中的两项">一个分布式系统只能满足 一致性 可用性 分区容错性中的两项<a class="post-anchor" href="#一个分布式系统只能满足-一致性-可用性-分区容错性中的两项"></a></h3><p><strong>分区容错性是分布式系统的基本要求，所有一般在C和A做权衡。</strong></p><p><strong>因为如果放弃P只能采用单点部署的方式，这样就放弃了可扩展性，也就无所谓的分布式系统了。</strong></p><p>一个分布式系统只能满足 一致性 可用性 分区容错性中的两项<br>分区容错性是分布式系统的基本要求，所有一般在C和A做权衡。<br>因为如果放弃P只能采用单点部署的方式，这样就放弃了可扩展性，也就无所谓的分布式系统了。<br>放弃A，如果发生网络故障或为了保证一致性，那么受到影响的服务需要等待一定时间，这段时间内系统无法对外提供正常的服务。<br>放弃C，实际上是放弃数据的强一致性，而保留数据的最终一致性。（强一致性，是指针对一个数据的更新操作成功后，所有用户都能读取到最新的数据）</p><h2 id="关注点">关注点<a class="post-anchor" href="#关注点"></a></h2><p>互相连接</p><p>数据而非系统</p><p>涉及读写操作</p><p>CAP 是忽略网络延迟的</p><p>正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足CA</p><h2 id="设计约束">设计约束<a class="post-anchor" href="#设计约束"></a></h2><h3 id="一致性Consistency">一致性Consistency<a class="post-anchor" href="#一致性Consistency"></a></h3><p><strong>版本</strong></p><ul><li><p>版本一：所有节点同一时刻能看到相同数据</p></li><li><p>版本二：对某个制定的客户端，保证读操作能够返回最新的写操作结果</p></li></ul><p><strong>这里的一致性指是「 线性一致性 」</strong></p><p><strong>C: Consistency 一致性</strong></p><ul><li>Consistency（一致性）</li></ul><p><strong>数据是否在多个副本之间能否保持一致</strong></p><p><strong>任何事物应该都是原子的，所有副本上的状态都是事物成功提交后的结果，并保持强一致</strong></p><p><strong>一致性(Consistency) 客户端知道一系列的操作都会同时发生(生效)</strong></p><p><strong>所有节点访问同一份最新的数据副本</strong></p><ul><li>设置定时器，放弃强一致性，达到最终一致性</li></ul><p><strong>任何时候所有的应用程序都能访问得到相同的数据</strong></p><ul><li>即所有的节点都能访问同一份最新的数据副本</li></ul><p><strong>Consistency 一致性</strong></p><ul><li>ACID理论</li></ul><p><strong>Consistency</strong></p><ul><li><p>因为在分布式的系统中P一定是要被考虑到的，所以就只剩下 AP和CP两个选项</p><ul><li>可用性</li></ul></li></ul><p><strong>Consistency(一致性)</strong></p><ul><li><p>如果系统一个操作返回成功，那么之后的读请求都必须读取到这个数据</p></li><li><p>如果系统一个操作返回失败，那么之后所有的读操作都不能读取这个数据</p></li><li><p>对调用者而言数据具有强一致性(strong consistency)。即原子性 atomic、线性一致性 linearizable consistency</p></li></ul><h3 id="可用性Availability">可用性Availability<a class="post-anchor" href="#可用性Availability"></a></h3><p><strong>要素</strong></p><ul><li><p>（1）有限时间内</p></li><li><p>（2）返回正常结果</p></li></ul><p><strong>版本</strong></p><ul><li><p>版本一：每个请求都能得到成功或失败的响应</p></li><li><p>版本二：非故障的节点在合理时间内返回合理的响应（不是错误或尝试的响应）</p></li></ul><p><strong>A: Availability 可用性(指的是快速获取数据)</strong></p><p><strong>可用性</strong></p><ul><li>系统服务一直处于可用状态.(总能在有限时间内返回结果)</li></ul><p><strong>保证每个请求不管成功或失败都有响应</strong></p><p><strong>可用性(Availability)</strong></p><ul><li><p>每个操作都必须以可预期的响应结束</p></li><li><p>每次请求都能获取到非错的响应，所有的读和写都必须要能终止</p></li></ul><p><strong>任何时候任何程序都可以读写数据</strong></p><ul><li><p>在集群中一部分节点故障后，集群整体是否还能响应客户的读写请求</p></li><li><p>即对数据更新具备高可用性</p></li></ul><p><strong>Availability</strong></p><ul><li>因为在分布式的系统中P一定是要被考虑到的，所以就只剩下 AP和CP两个选项</li></ul><p><strong>可用性（Availability）</strong></p><ul><li><p>系统提供的服务必须一直处于可用状态，对于每一个操作请求总是能够在有限时间（区分场景）内返回结果</p></li><li><p>所有读写请求在一定时间内响应，可终止、不会一直等待</p></li><li><p>非故障的节点再合理的时间内返回合理的响应</p></li><li><p>系统能在有限时间内完成对操作请求的应答</p></li></ul><h3 id="分区容错性Partition-tolerance">分区容错性Partition tolerance<a class="post-anchor" href="#分区容错性Partition-tolerance"></a></h3><p><strong>概述</strong></p><ul><li><p>分区容错性(Partition tolerance)</p><ul><li>P: Tolerance of network Partition 分区容忍性(分布式) </li></ul></li><li><p>即使出现单个组件无法可用,操作依然可以完成</p></li><li><p>必须需要实现</p><ul><li><p>遇到某节点或网络分区故障的时候仍然可以提供一致性和可用性的服务</p></li><li><p>对于分布式系统来说，P是不能放弃的</p></li></ul></li><li><p>分布式系统在遇到任何网络分区故障的时候，<br>仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p></li><li><p>要保证分区容错, 就只能在一致性和可用性之间 选择一个,如果选择可用性,则数据会不一致,如果保证数据一致,则不可用.</p></li><li><p>当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。<br>这时分区就是无法容忍的。</p></li><li><p>提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。<br>容忍性就提高了。</p></li></ul><p><strong>版本</strong></p><ul><li><p>版本一：出现消息丢失或分区错误时系统能够继续运行</p></li><li><p>版本二：当出现网络分区后，系统能后继续履行职责</p></li></ul><p><strong>网络分区容错性</strong></p><ul><li><p>当系统出现分区,出现多个网络分区,分区间网络不可达, 要保证能访问数据,就一定需要保证数据冗余多副本保存.所以网络分区容错可以理解为数据副本冗余.<br>即使因为网络或者其他原因,某些节点退出,分布式系统也能恢复(要求数据冗余). 即使分布式系统内部不需要互相访问,也要考虑节点挂掉的影响.</p></li><li><p>分区容错性是一个最基本的要求。因为既然是一个分布式系统，<br>那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。<br>而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。<br>因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡</p></li></ul><p><strong>系统可以跨网络分区线性的伸缩和扩展</strong></p><ul><li>分区相当于对通信的实现要求，系统如果不能在时限内达成数据的一致性，就意味着发生了分区的情况</li></ul><p><strong>Partition Tolerance 分隔容忍</strong></p><p><strong>Partition-tolerance</strong></p><ul><li>大部分的分布式系统都分布在不同子网络之间，每个子网络就属于一个分区，分区容错指的就是区间的通信有可能失败，那么如果通信失败则就会出现多个分区，所以在分布式的系统中P一定是满足的，除非你的服务只部署在一台机器上面</li></ul><p><strong>系统在遇到任何网络分区故障时，仍然能够保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障</strong></p><p><strong>在网络分区的情况下，被分隔的节点仍能正常对外服务</strong></p><ul><li>当出现网络分区后，系统能够继续”履行职责”</li></ul><p><strong>系统中的网络可能发生分区故障，即节点之间的通信无法保障。<br>而网络故障不应该影响到系统正常服务</strong></p><p><strong>限制条件</strong></p><ul><li>网络本身无法做到100%可靠，所以必须保证分区容忍性</li></ul><h2 id="组合-应用">组合(应用)<a class="post-anchor" href="#组合-应用"></a></h2><h3 id="CA">CA<a class="post-anchor" href="#CA"></a></h3><p><strong>放弃分区容错性，加强一致性和可用性，<br>其实就是传统的单机数据库的选择</strong></p><p><strong>弱化分区容忍性</strong></p><ul><li>现实中，网络分区出现概率较小，但很难完全避免。<br>两阶段的提交算法，某些关系型数据库以及 ZooKeeper 主要考虑了这种设计。<br>实践中，网络可以通过双通道等机制增强可靠性，实现高稳定的网络通信。</li></ul><p><strong>不能容忍网络错误或节点错误，一旦出现，整个系统拒绝写请求</strong></p><ul><li><p>网络本身无法做到100%可靠，有可能出故障，所以分区时一个必然的现象。</p></li><li><p>因为系统不知道对面节点是否挂掉还是只是网络问题，唯一安全做法是把自己变成只读</p></li><li><p>单节点挂了 ,就完蛋了</p></li></ul><p><strong>关注一致性和可用性</strong></p><ul><li><p>需要非常严格的全体一致性协议</p><ul><li><p>2PC(两阶段提交)</p></li><li><p>3PC(三阶段提交)</p></li></ul></li><li><p>此时的可用性的不是指多节点高可用的可用性</p></li></ul><h3 id="CP">CP<a class="post-anchor" href="#CP"></a></h3><p><strong>关注一致性和分区容忍性</strong></p><ul><li><p>大多数一致性协议</p><ul><li><p>Paxos算法</p></li><li><p>Quorum类的算法</p></li></ul></li></ul><p><strong>保证大多数节点数据一致，<br>少数节点会在数据未同步到最新版本之前处于不可用状态</strong></p><p><strong>放弃可用性，追求一致性和分区容错性，<br>基本不会选择，网络问题会直接让整个系统不可用</strong></p><p><strong>zk是放弃可用性</strong></p><p><strong>放弃A，如果发生网络故障或为了保证一致性</strong></p><ul><li>那么受到影响的服务需要等待一定时间，<br>这段时间内系统无法对外提供正常的服务。</li></ul><p><strong>既保证最新数据返回</strong></p><p><strong>取到非最新数据时返回错误</strong></p><p><strong>CP 架构</strong></p><ul><li>二个节点N1、N2，复制通道中断，数据无法同步到 N2，<br>客户端访问 N2，返回 error，违背了可用性，因此只能选择 CP</li></ul><p><strong>弱化可用性</strong></p><ul><li><p>对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis、MapReduce 等为此设计。</p></li><li><p>Paxos、Raft 等共识算法，主要处理这种情况。<br>在 Paxos 类算法中，可能存在着无法提供可用结果的情形，同时允许少数节点离线。</p></li></ul><h3 id="AP">AP<a class="post-anchor" href="#AP"></a></h3><p><strong>关注可用性和分区容忍性</strong></p><ul><li><p>不能达成一致性要求，需要给出数据冲突，给出数据冲突就需要维护数据版本</p></li><li><p>保证都能返回数据，可以多版本</p><ul><li>二个节点N1、N2，复制通道中断，数据无法同步到 N2，<br>客户端访问 N2，返回 旧的值，不能满足一致性，因此只能选择AP</li></ul></li></ul><p><strong>Dynamo</strong></p><p><strong>AP</strong></p><ul><li><p>例如很多NoSQL系统就是如此，异步复制，一致性很弱</p></li><li><p>放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，<br>这是很多分布式系统设计时的选择，</p></li></ul><p><strong>放弃C，实际上是放弃数据的强一致性，而保留数据的最终一致性。</strong></p><ul><li>强一致性，是指针对一个数据的更新操作成功后，所有用户都能读取到最新的数据</li></ul><p><strong>总结：基于 Paxos 算法构建的分布式系统，属于 CAP 架构哪一种？</strong></p><ul><li><p>Paxos 算法提供最终一致性保证</p><ul><li>符合 CP 方案</li></ul></li><li><p>大部分集群方案都是 AP 方案</p></li></ul><p><strong>弱化一致性。</strong></p><ul><li>对结果一致性不敏感的应用，<br>如：静态页面内容、实时性较弱的查询类数据库等。允许一段时间才最终更新成功，期间不保证一致性</li></ul><h2 id="实例">实例<a class="post-anchor" href="#实例"></a></h2><p>1.关系型数据库一般选择C（一致性）与A（可用性）。</p><p>2.HBase选择了C（一致性）与P（分区可容忍性）</p><p>3.Cassandra选择了A（可用性）与P（分区可容忍性）</p><h2 id="CAP关键细节点">CAP关键细节点<a class="post-anchor" href="#CAP关键细节点"></a></h2><p>关注粒度是数据，而不是整个系统</p><p>忽略网络延迟的</p><h3 id="正常运行情况下，不存在-CP、AP-的选择，可以同时满足-CA">正常运行情况下，不存在 CP、AP 的选择，可以同时满足 CA<a class="post-anchor" href="#正常运行情况下，不存在-CP、AP-的选择，可以同时满足-CA"></a></h3><p><strong>分区发生时选择 CP 或 AP</strong></p><p><strong>没有分区时，也要考虑如何保证 CA</strong></p><p>放弃并不等于什么都不做，需要为分区恢复后做准备</p><h2 id="误区">误区<a class="post-anchor" href="#误区"></a></h2><h3 id="关于P的理解">关于P的理解<a class="post-anchor" href="#关于P的理解"></a></h3><p><strong>Partition：网络分区，即因网络因素将系统分隔为多个单独的部分</strong></p><p><strong>有人说，网络分区的情况发生的概率非常小，是不是不用考虑P，保证CA就好</strong></p><ul><li>现实情况是我们面对的是一个不可靠的网络、有一定的概率宕机的设备，<br>这两个因素都会导致Partition，因此分布式系统实现中P是一个必须项，而不是一个可选项。</li></ul><p><strong>CAP中P的定义</strong></p><ul><li><p>In order to model partition tolerance, the network will be allowed lose arbitrarily many messages sent from one node to another.</p></li><li><p>网络允许从一个节点到另一个的任意的多个消息的丢失</p></li><li><p>分区容忍性意味着通过降低系统的其他属性来开发一个复制策略。</p></li></ul><p><strong>网络分区、网络丢包、节点宕机都符合CAP中P的定义</strong></p><h3 id="CA非0-1的选择">CA非0/1的选择<a class="post-anchor" href="#CA非0-1的选择"></a></h3><p><strong>工程实践中一致性有不同程度，可用性也有不同等级，<br>在保证分区容错性的前提下，放宽约束后可以兼容一致性和可用性，两者不是非此即彼</strong></p><p><strong>CAP定理中的一致性指强一致性</strong></p><ul><li><p>强一致性要求多个节点组成的被调用能像单个节点一样允许、操作具备原子性，在数据和时序上都有要求</p></li><li><p>放宽时间、时序要求</p><ul><li><p>sequential consistency（序列一致性）</p><ul><li>不要去时序一致</li></ul></li><li><p>enventual consistency（最终一致性）</p><ul><li>放宽对时间的要求</li></ul></li></ul></li></ul><p><strong>可用性在CAP定理中指所有读写操作必须要能终止</strong></p><ul><li><p>实际应用中从主调、被调视觉来看，可用性具有不同的含义</p><ul><li>当P(网络分区)出现时，主调可以只支持读操作，通过牺牲部分可用性达成数据一致</li></ul></li><li><p>工程实践中，较常见的做法是通过异步拷贝副本(asynchronous replication)、quorum/NRW，<br>实现在调用端看来数据强一致、被调端最终一致，在调用端看来服务可用、被调端允许部分节点不可用(或被网络分隔)的效果</p></li></ul><h3 id="跳出CAP">跳出CAP<a class="post-anchor" href="#跳出CAP"></a></h3><p><strong>CAP理论对实现分布式系统具有指导意义，<br>但CAP理论并没有涵盖分布式工程实践中的所有重要因素</strong></p><p><strong>延时（latency）</strong></p><ul><li><p>衡量系统可用性、与用户体验直接相关的一项重要指标</p></li><li><p>加上延时考虑</p><ul><li><p>CAP理论修改版：PACELC</p><ul><li>如果出现P(网络分区)，如何在A(服务可用性)、C(数据一致性)之间选择；<br>否则，如何在L(延时)、C(数据一致性)之间选择。</li></ul></li></ul></li><li><p>如果要达到强一致性、多个副本数据一致，必然增加延时</p></li></ul><p><strong>CAP理论中的可用性要求操作能终止、不无休止地进行</strong></p><h2 id="其他">其他<a class="post-anchor" href="#其他"></a></h2><p>为什么不能都保证</p><h2 id="分布式领域CAP理论，">分布式领域CAP理论，<a class="post-anchor" href="#分布式领域CAP理论，"></a></h2><p>Consistency(一致性), 数据一致更新，所有数据变动都是同步的</p><p>Availability(可用性), 好的响应性能</p><p>Partition tolerance(分区容忍性) 可靠性</p><p>定理：任何分布式系统只可同时满足二点，没法三者兼顾。</p><p>忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。</p><h1 id="BASE"><strong>BASE</strong><a class="post-anchor" href="#BASE"></a></h1><h2 id="概述-1">概述<a class="post-anchor" href="#概述-1"></a></h2><p>BASE 理论是 Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p><p>完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，<br>并允许数据在一段时间内是不一致的，但最终达到一致状态</p><p>指基本可以、软状态、最终一致性，核心思想是即使无法做到强一致性，但可以采用适合的方式达到最终一致性</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的</p><p>BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：</p><h2 id="约束">约束<a class="post-anchor" href="#约束"></a></h2><h3 id="基本可用（Basically-Available）">基本可用（Basically Available）<a class="post-anchor" href="#基本可用（Basically-Available）"></a></h3><p><strong>概述</strong></p><ul><li><p>指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</p></li><li><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，<br>这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p></li><li><p>支持分区失败(e.g. sharding碎片划分数据库)</p></li><li><p>分布式系统再出现故障时，允许损失部分可用性，即保证核心可用</p></li><li><p>关键字：部分、核心，根据业务选择</p></li><li><p>在分布式系统出现不可预知的故障时, 允许损失部分可用性</p></li></ul><p><strong>损失</strong></p><ul><li><p>响应时间上的损失</p><ul><li><p>响应时间增长.但不会失败</p></li><li><p>响应时间上的损失</p><ul><li>正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，<br>但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li></ul></li></ul></li><li><p>功能上的损失</p><ul><li><p>部分功能不可用</p></li><li><p>系统功能上的损失，网页降级</p></li><li><p>当流量高峰期时，<br>屏蔽一些功能的使用以保证系统稳定性（服务降级）</p><ul><li>正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，<br>但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li></ul></li></ul><h3 id="软状态（-Soft-State）">软状态（ Soft State）<a class="post-anchor" href="#软状态（-Soft-State）"></a></h3><p><strong>指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，<br>即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</strong></p><p><strong>允许系统存在中间状态，而该中间状态不会影响系统整体可用性</strong></p><ul><li><p>不同节点的数据副本之间进行数据同步的过程存在延时</p></li><li><p>状态可以有一段时间不同步，异步。</p></li></ul><p><strong>Soft-state –软状态/柔性事务</strong></p><ul><li><p>“Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的</p></li><li><p>和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，<br>即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。比如支付过程</p></li></ul><h3 id="最终一致性（-Eventual-Consistency）">最终一致性（ Eventual Consistency）<a class="post-anchor" href="#最终一致性（-Eventual-Consistency）"></a></h3><p><strong>概述</strong></p><ul><li><p>强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态。<br>因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p></li><li><p>所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态</p></li><li><p>允许数据在一段时间内是不一致的，但系统中的所有数据副本在经过一段时间的同步之后，最终能够达到一致的状态</p><ul><li>需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</li></ul></li><li><p>关键字</p><ul><li>一定时间、最终。不同的数据能够容忍的不一致时间是不同的</li></ul></li></ul><p><strong>分类</strong></p><ul><li><p>（1）因果一致性（Causal consistency）</p><ul><li>即进程A在更新完数据后通知进程B，那么之后进程B对该项数据的范围都是进程A更新后的最新值。</li></ul></li><li><p>（2）读己之所写（Read your writes）</p><ul><li>进程A更新一项数据后，它自己总是能访问到自己更新过的最新值。</li></ul></li><li><p>（3）会话一致性（Session consistency）</p><ul><li>将数据一致性框定在会话当中，在一个会话当中实现读己之所写的一致性。<br>即执行更新后，客户端在同一个会话中始终能读到该项数据的最新值</li></ul></li><li><p>（4）单调读一致性（Monotonic read consistency）</p><ul><li>如果一个进程从系统中读取出一个数据项的某个值后，<br>那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li></ul></li><li><p>（5）单调写一致性（Monotoic write consistency）</p><ul><li>一个系统需要保证来自同一个进程的写操作被顺序执行。</li></ul></li></ul><h2 id="核心思想">核心思想<a class="post-anchor" href="#核心思想"></a></h2><p>即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，<br>采用适当的方式来使系统达到最终一致性（Eventual consistency）</p><h3 id="BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是">BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是<a class="post-anchor" href="#BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是"></a></h3><p><strong>无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</strong></p><p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，<br>采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p><h2 id="其他-1">其他<a class="post-anchor" href="#其他-1"></a></h2><h3 id="BASE（FROM-EBay）">BASE（FROM EBay）<a class="post-anchor" href="#BASE（FROM-EBay）"></a></h3><hr><p><strong>过程</strong></p><ul><li><p>分布式事务转化成多个本地事务</p></li><li><p>在第一阶段，通过本地的数据库的事务保障，增加了 transaction 表及消息队列 。</p></li><li><p>在第二阶段，分别读出消息队列（但不删除），<br>通过判断更新记录表 updates_applied 来检测相关记录是否被执行，<br>未被执行的记录会修改 user 表，<br>然后增加一条操作记录到 updates_applied，<br>事务执行成功之后再删除队列。</p></li></ul><h3 id="跨数据库两段提交事务">跨数据库两段提交事务<a class="post-anchor" href="#跨数据库两段提交事务"></a></h3><p><strong>2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，<br>JavaEE中的JTA事务可以支持2PC。<br>因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。</strong></p><h3 id="BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：">BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：<a class="post-anchor" href="#BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性："></a></h3><p><strong>Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库)</strong></p><p><strong>Soft state软状态 状态可以有一段时间不同步，异步。</strong></p><p><strong>Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。</strong></p><h2 id="实现">实现<a class="post-anchor" href="#实现"></a></h2><h3 id="BASE思想的主要实现有">BASE思想的主要实现有<a class="post-anchor" href="#BASE思想的主要实现有"></a></h3><p><strong>1.按功能划分数据库</strong></p><p><strong>2.sharding碎片</strong></p><p>BASE思想主要强调基本的可用性，如果你需要高可用性，也就是纯粹的高性能，<br>那么就要以一致性或容忍性为牺牲，BASE思想的方案在性能上还是有潜力可挖的。</p><h3 id="现在NOSQL运动丰富了拓展了BASE思想，可按照具体情况定制特别方案，比如忽视一致性，获得高可用性等等，NOSQL应该有下面两个流派：">现在NOSQL运动丰富了拓展了BASE思想，可按照具体情况定制特别方案，比如忽视一致性，获得高可用性等等，NOSQL应该有下面两个流派：<a class="post-anchor" href="#现在NOSQL运动丰富了拓展了BASE思想，可按照具体情况定制特别方案，比如忽视一致性，获得高可用性等等，NOSQL应该有下面两个流派："></a></h3><p><strong>流派</strong></p><ul><li><ol><li>Key-Value存储，如Amaze Dynamo等，可根据CAP三原则灵活选择不同倾向的数据库产品。</li></ol></li><li><ol start="2"><li>领域模型 + 分布式缓存 + 存储 （Qi4j和NoSql运动），<br>可根据CAP三原则结合自己项目定制灵活的分布式方案，难度高。</li></ol></li></ul><p><strong>共同点</strong></p><ul><li>都是关系数据库SQL以外的可选方案，逻辑随着数据分布，任何模型都可以自己持久化，<br>将数据处理和数据存储分离，将读和写分离，存储可以是异步或同步，取决于对一致性的要求程度。</li></ul><p><strong>不同点</strong></p><ul><li>NOSQL之类的Key-Value存储产品是和关系数据库头碰头的产品BOX，可以适合非Java如PHP RUBY等领域，是一种可以拿来就用的产品，<br>而领域模型 + 分布式缓存 + 存储是一种复杂的架构解决方案，不是产品，但这种方式更灵活，更应该是架构师必须掌握的。</li></ul><h1 id="色彩"><strong>色彩</strong><a class="post-anchor" href="#色彩"></a></h1><p>红色</p><p>蓝色</p><p>绿色</p><h1 id="CAP和BASE相关点"><strong>CAP和BASE相关点</strong><a class="post-anchor" href="#CAP和BASE相关点"></a></h1><h2 id="CAP-理论时忽略延时的，而实际应用中延时是无法避免的">CAP 理论时忽略延时的，而实际应用中延时是无法避免的<a class="post-anchor" href="#CAP-理论时忽略延时的，而实际应用中延时是无法避免的"></a></h2><p>CP 实际上也是最终一致性，一定时间是几毫米而已</p><h2 id="AP-方案中牺牲一致性只是指分区期间，而不是永远放弃一致性">AP 方案中牺牲一致性只是指分区期间，而不是永远放弃一致性<a class="post-anchor" href="#AP-方案中牺牲一致性只是指分区期间，而不是永远放弃一致性"></a></h2><p>分区故障恢复后，系统应达到最终一致性</p><p> CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸</p><h1 id="ACID"><strong>ACID</strong><a class="post-anchor" href="#ACID"></a></h1><h2 id="事务">事务<a class="post-anchor" href="#事务"></a></h2><p>程序执行单元，里面的操作要么全部执行成功，要么全部执行失败</p><h2 id="定义">定义<a class="post-anchor" href="#定义"></a></h2><p>事务的ACID特性</p><h3 id="ACID-也是一种比较出名的描述一致性的原则，-通常出现在分布式数据库等基于事务过程的系统中。-以牺牲可用性为代价">ACID 也是一种比较出名的描述一致性的原则， 通常出现在分布式数据库等基于事务过程的系统中。 以牺牲可用性为代价<a class="post-anchor" href="#ACID-也是一种比较出名的描述一致性的原则，-通常出现在分布式数据库等基于事务过程的系统中。-以牺牲可用性为代价"></a></h3><p><strong>A即 Atomicity（原子性）。每次事务是原子的，事务包含的所有操作要么全部成功，要么全部不执行。 一旦有操作失败，则需要回退状态到执行事务之前</strong></p><p><strong>C即 Consistency（一致性）。<br>数据库的状态在事务执行前后的状态是一致的和完整的，无中间状态。<br> 即只能处于成功事务提交后的状态</strong></p><p><strong>I 即  Isolation（隔离性）。各种事务可以并发执行，但彼此之间互相不影响。<br>按照标准 SQL 规范，从弱到强可以分为未授权读取、授权读取、可重复读取和串行化四种隔离等级</strong></p><p><strong>D即 Durability（持久性）。 状态的改变是持久的，不会失效。<br>一旦某个事务提交，则它造成的状态变更就是永久性的</strong></p><h3 id="关系数据库的ACID模型拥有-高一致性-可用性-很难进行分区">关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区<a class="post-anchor" href="#关系数据库的ACID模型拥有-高一致性-可用性-很难进行分区"></a></h3><p><strong>与之相对应的是BASE（Basic Availability，Soft-state，Eventual Consistency）原则。<br>BASE 原则面向大型高可用分布式系统，主张牺牲掉对强一致性的追求，而实现最终一致性，来换取一定的可用性。</strong></p><p>数据库管理系统为了保证事务的正确性而提出来的一个理论</p><p>ACID 是数据库事务完整性理论</p><h2 id="约束-1">约束<a class="post-anchor" href="#约束-1"></a></h2><h3 id="原子性（Atomicity）">原子性（Atomicity）<a class="post-anchor" href="#原子性（Atomicity）"></a></h3><p><strong>Atomicity(目标)</strong></p><p><strong>事务是最小的执行单位</strong></p><p><strong>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。<br>事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</strong></p><p><strong>即不可分割，事务要么全部被执行，要么全部不执行。<br>如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生变化；<br>如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换。</strong></p><p><strong>对一个事务内的操作来说，整个事务是原子的，要么内部的执行（插入或更新）全部成功，<br>要么事务失败，所有操作回滚</strong></p><p><strong>事务是一个不可分割的整体，所有操作要么全做，要么全不做；只要事务中有一个操作出错，<br>回滚到事务开始前的状态的话，那么之前已经执行的所有操作都是无效的，都应该回滚到开始前的状态</strong></p><p><strong>事务中的操作是原子的，一个事务中的所有操作，要么全部完成，要么全部不完成，不会再中间某个环节结束</strong></p><p><strong>事务中各项操作，要么全做要么不做，任何一项操作的失败都会导致整个事务的失败</strong></p><p><strong>一个事务必须是一个不可分割的最小工作单元，整个事务的全部操作，要么全部提交成功，要么全部失败回滚，不可能执行其中一部分。</strong></p><h3 id="一致性（Consistency）">一致性（Consistency）<a class="post-anchor" href="#一致性（Consistency）"></a></h3><p><strong>Consistency(约束)</strong></p><p><strong>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。<br>这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</strong></p><p><strong>事务的执行使得数据库从一种正确状态转换成另外一种正确状态。</strong></p><p><strong>不受并发等影响，事务执行成功，则数据是确定的</strong></p><p><strong>事务执行前后，数据从一个状态到另一个状态必须是一致的，<br>比如A向B转账（A、B的总金额就是一个一致性状态），不可能出现A扣了钱，B却没收到的情况发生。</strong></p><p><strong>再事务开始之前和事务结束以后，数据库的完整性没有被破坏</strong></p><p><strong>在事务开始或结束时，数据库应该在一致状态。</strong></p><ul><li>数据库事务执行的结果总是从一个一致性的状态转换到另外一个一致性状态。没有中间状态</li></ul><p><strong>执行完后，数据保证一致</strong></p><ul><li><p>事务结束后系统状态是一样的</p></li><li><p>一旦事务完成,系统必须确保所建模业务一致状态</p></li></ul><p><strong>规则一致性</strong></p><ul><li><p>主键约束</p></li><li><p>唯一键约束</p></li><li><p>外键约束</p></li></ul><p><strong>逻辑一致性</strong></p><ul><li><p>悲观锁</p></li><li><p>乐观锁</p></li><li><p>双重锁检查</p></li><li><p>balking模式</p></li></ul><h3 id="隔离性（Isolation）">隔离性（Isolation）<a class="post-anchor" href="#隔离性（Isolation）"></a></h3><p><strong>概述</strong></p><ul><li><p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。<br>事务隔离分为不同级别</p></li><li><p>事务与事务之间不受影响，中间状态不可见</p><ul><li><p>并发执行的事务彼此无法看到对方的中间状态</p></li><li><p>防止多个事务并发执行时由于交叉执行而导致数据的不一致</p></li><li><p>一个事务的执行不能被其它事务干扰</p><ul><li>并发执行时，事务不被其他事务所干扰</li></ul></li><li><p>事务将假定只有它自己在操作数据库，彼此不知晓。</p></li><li><p>事务之间的隔离级别，对其他事务的可见性。<br>通常一个事务所做的修改在最终提交之前 对其他事务是不可见的。</p></li><li><p>在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，<br>即在事务正确提交之前，它可能的结果不应该显示给其他事务。</p></li></ul></li><li><p>事务之间彼此隔离,往往涉及到锁定数据库中行或表</p></li><li><p>多个并发事务之间相互隔离，不能互相干扰。</p></li><li><p>关于事务的隔离性，可能不是特别好理解，这里的并发事务是指两个事务操作了同一份数据的情况；<br>而对于并发事务操作同一份数据的隔离性问题，则是要求不能出现脏读、幻读的情况，<br>即事务A不能读取事务B还没有提交的数据，或者在事务A读取数据进行更新操作时，不允许事务B率先更新掉这条数据。<br>而为了解决这个问题，常用的手段就是加锁了，对于数据库来说就是通过数据库的相关锁机制来保证。</p></li></ul><p><strong>事务隔离级别</strong></p><ul><li><p>读未提交（Read uncommitted）</p><ul><li>Read Uncommitted（读取未提交内容）</li></ul></li><li><p>读提交（read committed）</p><ul><li>Read Committed（读取提交内容）</li></ul></li><li><p>可重复读（repeatable read）</p><ul><li>Repeatable Read（可重读）</li></ul></li><li><p>串行化（Serializable）</p><ul><li>Serializable（可串行化）</li></ul></li></ul><p><strong>问题</strong></p><ul><li><p>脏读</p></li><li><p>不可重复读</p></li><li><p>幻读</p></li></ul><h3 id="持久性（Durability）">持久性（Durability）<a class="post-anchor" href="#持久性（Durability）"></a></h3><p><strong>一旦事务正确提交 ，则其所做的修改就会永久保存在数据库中，不能回滚。<br>即使在事务提交之后有了其他故障，即使系统崩溃，事务的处理结果也会得到保存，修改的数据也不会丢失。</strong></p><p><strong>一旦事务完成，就不能返回</strong></p><p><strong>事务完成后所做的改动都会持久化</strong></p><p><strong>Durability(架构)</strong></p><ul><li>架构师、DBA</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;以下为-mindmanager-的预览&quot;&gt;以下为 mindmanager 的预览&lt;a class=&quot;post-anchor&quot; href=&quot;#以下为-mindmanager-的预览&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;!-- TO
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>RBAC权限模型 - 基于角色的访问控制</title>
    <link href="http://takostar.net/2022/02212221/"/>
    <id>http://takostar.net/2022/02212221/</id>
    <published>2022-02-21T14:21:24.000Z</published>
    <updated>2022-02-26T16:27:07.698Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><!-- TODO:实现搜索框的按键展示(使用页面缩放?或者是弹性相应和直接style) --><div class="post-mindmap">  <iframe class="mindmap" id="mindmap" src="RBAC权限模型 - 基于角色的访问控制.html"></iframe>  <div class="r">  <span class="iconfont icon-close"></span>    <div class="tip"></div>    <a class="fullscreen-button">Full Screen</a></div></div>  <script type="text/javascript">    var sonWidth = document.getElementById("mindmap").offsetWidth;    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";</script><h1 id="RABC"><strong>RABC</strong><a class="post-anchor" href="#RABC"></a></h1><h2 id="概述">概述<a class="post-anchor" href="#概述"></a></h2><p>权限管理模型</p><h3 id="RBAC（Role-Based-Access-Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。">RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。<a class="post-anchor" href="#RBAC（Role-Based-Access-Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。"></a></h3><hr><p>RBAC是一套成熟的权限模型。在传统权限模型中，我们直接把权限赋予用户。<br>而在RBAC中，增加了“角色”的概念，我们首先把权限赋予角色，再把角色赋予用户。这样，由于增加了角色，授权会更加灵活方便。</p><p>在RBAC中，根据权限的复杂程度，又可分为RBAC0、RBAC1、RBAC2、RBAC3。<br>其中，RBAC0是基础，RBAC1、RBAC2、RBAC3都是以RBAC0为基础的升级。我们可以根据自家产品权限的复杂程度，选取适合的权限模型。</p><h3 id="RBAC-认为授权实际上是Who-、What-、How-三元组之间的关系，也就是Who-对What-进行How-的操作，也就是“主体”对“客体”的操作。">RBAC  认为授权实际上是Who 、What 、How 三元组之间的关系，也就是Who 对What 进行How 的操作，也就是“主体”对“客体”的操作。<a class="post-anchor" href="#RBAC-认为授权实际上是Who-、What-、How-三元组之间的关系，也就是Who-对What-进行How-的操作，也就是“主体”对“客体”的操作。"></a></h3><p><strong>Who：是权限的拥有者或主体（如：User，Role）。</strong></p><p><strong>What：是操作或对象（operation，object）。</strong></p><p><strong>How：具体的权限（Privilege,正向授权与负向授权）。</strong></p><h2 id="组成">组成<a class="post-anchor" href="#组成"></a></h2><h3 id="User">User<a class="post-anchor" href="#User"></a></h3><p><strong>用户</strong></p><h3 id="Role">Role<a class="post-anchor" href="#Role"></a></h3><p><strong>角色</strong></p><p><strong>分类</strong></p><ul><li><p>admin</p></li><li><p>user</p></li><li><p>……</p></li></ul><h3 id="Resource-Permission">Resource(Permission)<a class="post-anchor" href="#Resource-Permission"></a></h3><p><strong>权限/资源</strong></p><p><strong>分类</strong></p><ul><li><p>功能权限</p><ul><li>模块</li></ul></li><li><p>菜单权限</p><ul><li>页内按钮操作</li></ul></li><li><p>数据级</p></li><li><p>uri权限</p><ul><li><p>页面，代表前端路由地址</p></li><li><p>按钮，代表后端接口地址</p></li></ul></li></ul><h2 id="扩展">扩展<a class="post-anchor" href="#扩展"></a></h2><p>用户组</p><p>菜单</p><h2 id="分类">分类<a class="post-anchor" href="#分类"></a></h2><h3 id="基本模型RBAC0">基本模型RBAC0<a class="post-anchor" href="#基本模型RBAC0"></a></h3><p><strong>介绍</strong></p><ul><li><p>RBAC0是基础，很多产品只需基于RBAC0就可以搭建权限模型了。<br>在这个模型中，我们把权限赋予角色，再把角色赋予用户。用户和角色，角色和权限都是多对多的关系。<br>用户拥有的权限等于他所有的角色持有权限之和。</p></li><li><p>举例</p><ul><li>譬如我们做一款企业管理产品，如果按传统权限模型，给每一个用户赋予权限则会非常麻烦，并且做不到批量修改用户权限。<br>这时候，可以抽象出几个角色，譬如销售经理、财务经理、市场经理等，然后把权限分配给这些角色，再把角色赋予用户。<br>这样无论是分配权限还是以后的修改权限，只需要修改用户和角色的关系，或角色和权限的关系即可，更加灵活方便。<br>此外，如果一个用户有多个角色，譬如王先生既负责销售部也负责市场部，那么可以给王先生赋予两个角色，即销售经理+市场经理，这样他就拥有这两个角色的所有权限。</li></ul></li></ul><p><strong>RBAC0模型图</strong></p><ul><li>……</li></ul><p><strong>RBAC0适用场景</strong></p><p><strong>评价</strong></p><h3 id="角色分层模型RBAC1">角色分层模型RBAC1<a class="post-anchor" href="#角色分层模型RBAC1"></a></h3><p><strong>RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念。<br>简单理解就是，给角色可以分成几个等级，每个等级权限不同，从而实现更细粒度的权限管理。</strong></p><hr><p><strong>举例</strong></p><ul><li>基于之前RBAC0的例子，我们又发现一个公司的销售经理可能是分几个等级的，譬如除了销售经理，还有销售副经理，而销售副经理只有销售经理的部分权限。<br>这时候，我们就可以采用RBAC1的分级模型，把销售经理这个角色分成多个等级，给销售副经理赋予较低的等级即可。</li></ul><h3 id="角色限制模型RBAC2">角色限制模型RBAC2<a class="post-anchor" href="#角色限制模型RBAC2"></a></h3><p><strong>RBAC2同样建立在RBAC0基础之上，仅是对用户、角色和权限三者之间增加了一些限制。<br>这些限制可以分成两类，即静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。</strong></p><ul><li><p>静态职责分离SSD(Static Separation of Duty)</p></li><li><p>动态职责分离DSD(Dynamic Separation of Duty)。</p></li></ul><hr><p><strong>举例</strong></p><ul><li>还是基于之前RBAC0的例子，我们又发现有些角色之间是需要互斥的，譬如给一个用户分配了销售经理的角色，就不能给他再赋予财务经理的角色了，否则他即可以录入合同又能自己审核合同；<br>再譬如，有些公司对角色的升级十分看重，一个销售员要想升级到销售经理，必须先升级到销售主管，这时候就要采用先决条件限制了。</li></ul><h3 id="统一模型RBAC3">统一模型RBAC3<a class="post-anchor" href="#统一模型RBAC3"></a></h3><p><strong>RBAC3是RBAC1和RBAC2的合集，所以RBAC3既有角色分层，也包括可以增加各种限制。</strong></p><p><strong>RBAC3= RBAC1 + RBAC2</strong></p><h3 id="基于RBAC的延展——用户组">基于RBAC的延展——用户组<a class="post-anchor" href="#基于RBAC的延展——用户组"></a></h3><p><strong>基于RBAC模型，还可以适当延展，使其更适合我们的产品。譬如增加用户组概念，直接给用户组分配角色，再把用户加入用户组。<br>这样用户除了拥有自身的权限外，还拥有了所属用户组的所有权限。</strong></p><hr><p><strong>譬如，我们可以把一个部门看成一个用户组，如销售部，财务部，再给这个部门直接赋予角色，使部门拥有部门权限，这样这个部门的所有用户都有了部门权限。<br>用户组概念可以更方便的给群体用户授权，且不影响用户本来就拥有的角色权限。</strong></p><h2 id="实例">实例<a class="post-anchor" href="#实例"></a></h2><h3 id="实体">实体<a class="post-anchor" href="#实体"></a></h3><p><strong>用户表user</strong></p><ul><li><p>id</p></li><li><p>……</p><ul><li>其他用户相关信息</li></ul></li></ul><p><strong>角色表role</strong></p><ul><li><p>id</p></li><li><p>pid</p></li><li><p>name</p><ul><li>角色名称</li></ul></li><li><p>status</p><ul><li>是否禁用</li></ul></li><li><p>updated_time</p></li><li><p>created_time</p></li></ul><p><strong>权限表permission</strong></p><ul><li><p>id</p></li><li><p>name</p></li><li><p>url</p></li><li><p>status</p></li></ul><h3 id="关系">关系<a class="post-anchor" href="#关系"></a></h3><p><strong>用户角色表 UA</strong></p><ul><li><p>id</p></li><li><p>uid</p></li><li><p>role_id</p></li><li><p>created_time</p></li></ul><p><strong>权限角色表 PA</strong></p><ul><li><p>id</p></li><li><p>role_id</p></li><li><p>per_id</p></li><li><p>created_time</p></li></ul><h1 id="其他"><strong>其他</strong><a class="post-anchor" href="#其他"></a></h1><h2 id="ABAC">ABAC<a class="post-anchor" href="#ABAC"></a></h2><p>基于属性的权限验证（ABAC: Attribute-Based Access Control）</p><h2 id="DAC">DAC<a class="post-anchor" href="#DAC"></a></h2><h3 id="案例">案例<a class="post-anchor" href="#案例"></a></h3><p><strong>文件系统</strong></p><p>自主访问控制（DAC: Discretionary Access Control）</p><h2 id="MAC">MAC<a class="post-anchor" href="#MAC"></a></h2><p>强制访问控制（MAC: Mandatory Access Control）</p><h3 id="案例-1">案例<a class="post-anchor" href="#案例-1"></a></h3><p><strong>政府机密文件</strong></p><h3 id="要素">要素<a class="post-anchor" href="#要素"></a></h3><p><strong>控制体</strong></p><p><strong>权限标识</strong></p><p><strong>用户</strong></p><ul><li>权限标识</li></ul><h2 id="SAM">SAM<a class="post-anchor" href="#SAM"></a></h2><p>SAM(Security Access Manager)</p><p>有赞</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;以下为-mindmanager-的预览&quot;&gt;以下为 mindmanager 的预览&lt;a class=&quot;post-anchor&quot; href=&quot;#以下为-mindmanager-的预览&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;!-- TO
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="导图" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/%E5%AF%BC%E5%9B%BE/"/>
    
    
      <category term="鉴权" scheme="http://takostar.net/tags/%E9%89%B4%E6%9D%83/"/>
    
  </entry>
  
  <entry>
    <title>区块链共识算法分类总结</title>
    <link href="http://takostar.net/2022/02122235/"/>
    <id>http://takostar.net/2022/02122235/</id>
    <published>2022-02-12T14:35:51.000Z</published>
    <updated>2022-02-26T16:25:53.155Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><div class="post-mindmap">  <iframe class="mindmap" id="mindmap" src="区块链 - 技术 - 共识算法(机制).html"></iframe>  <div class="r">  <span class="iconfont icon-close"></span>    <div class="tip"></div>    <a class="fullscreen-button">Full Screen</a></div></div>  <script type="text/javascript">    var sonWidth = document.getElementById("mindmap").offsetWidth;    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";</script><h1 id="概述"><strong>概述</strong><a class="post-anchor" href="#概述"></a></h1><h2 id="介绍">介绍<a class="post-anchor" href="#介绍"></a></h2><p>数据同步的方法</p><p>所谓“共识机制”，是通过特殊节点的投票，在很短的时间内完成对交易的验证和确认；</p><h3 id="对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。">对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。<a class="post-anchor" href="#对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。"></a></h3><p><strong>再通俗一点来讲，如果中国一名微博大V、美国一名虚拟币玩家、一名非洲留学生和一名欧洲旅行者互不相识，<br>但他们都一致认为你是个好人，那么基本上就可以断定你这人还不坏。</strong></p><p>指可以使用所有节点对某一种状态达成一致的方式，<br>有共识机制去中心化才有意义，才具备可信度，否则只是数据共享</p><p>目前主流的共识机制有：POW、POS、DPOS、PBFT等</p><p>所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。 当加入区块链的节点足够多的时候，基本上不可能伪造出一条不存在的记录，从而杜绝了造假的可能。</p><h3 id="区块链的共识机制通常包含了两个方面">区块链的共识机制通常包含了两个方面<a class="post-anchor" href="#区块链的共识机制通常包含了两个方面"></a></h3><p><strong>达成共识的计算机算法，即共识算法（Consensus Algorithm）</strong></p><p><strong>达成共识的规则，即共识规则（Consensus Rule）</strong></p><h3 id="分布式一致性算法（共识机制）">分布式一致性算法（共识机制）<a class="post-anchor" href="#分布式一致性算法（共识机制）"></a></h3><p><strong>什么是共识， 什么是共识算法？</strong></p><ul><li>……</li></ul><hr><p><strong>Paxos</strong></p><p><strong>Raft</strong></p><p>所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。<br>区块链提出了四种不同的共识机制，适用于不同的应用场景，在效率和安全性之间取得平衡。</p><h3 id="区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中：">区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中：<a class="post-anchor" href="#区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中："></a></h3><p><strong>“少数服从多数”并不完全指节点个数，也可以是计算能力、股权数或者其他的计算机可以比较的特征量。</strong></p><p><strong>“人人平等”是当节点满足条件时，所有节点都有权优先提出共识结果、直接被其他节点认同后并最后有可能成为最终共识结果。 [8]</strong></p><p>以比特币为例，采用的是工作量证明，只有在控制了全网超过51%的记账节点的情况下，才有可能伪造出一条不存在的记录。<br>当加入区块链的节点足够多的时候，这基本上不可能，从而杜绝了造假的可能。</p><p>即便在网络通信可靠情况下，<br>一个可扩展的分布式系统的共识问题通用解法的下限是——没有下限（无解）</p><h2 id="目的">目的<a class="post-anchor" href="#目的"></a></h2><p>让分布式数据记录不可逆</p><p>选择节点产生区块</p><h2 id="作用">作用<a class="post-anchor" href="#作用"></a></h2><h3 id="分布式系统对某个提案，大部分节点达成一致意见的过程">分布式系统对某个提案，大部分节点达成一致意见的过程<a class="post-anchor" href="#分布式系统对某个提案，大部分节点达成一致意见的过程"></a></h3><p><strong>在区块链系统中没有像银行一样的中心化机构，所以在进行传输信息、价值转移时， 共识机制解决并保证每一笔交易在所有记帐节点上的一致性和正确性问题。<br> 区块链的这种新的共识机制使其在不依靠中心化组织的情况下，依然大规模高效协作完成运转</strong></p><p><strong>数据一致性要解决哪些问题</strong></p><ul><li><p>以谁的数据为准</p><ul><li><p>任何结点都可以修改自己所下载的账本，也就是任何一个人都可以伪造账本</p></li><li><p>在去中心化的网络下，我们只能认为，大多数人认识的数据是对的。<br>只要我控制了一半以上的结点，我让这 “ 大多数人 “ 伪造同一份账本，那么相当于整个账本都被我修改过来了</p></li><li><p>因为在没有服务器的去中心化的网络下，所谓的真理只不过是大多数人同意的东西。</p></li></ul></li><li><p>“ 大多数人 “ 的问题</p><ul><li>是人数吗？在网络世界里，我可以用程序模拟出无穷多的 “ 人 “ 出来投票，<br>所以，用人数来解决去中心化的问题，在分不清是人还是狗，是生物还是程序的计算机世界里，是一件很愚蠢的事。</li></ul></li><li><p>意见分歧问题</p><ul><li>如果在同一个时刻，有多个人都在告诉其它人，这账应该这么记 有人说，我转了10块给gg，又有人说，xx转了20块给我</li></ul></li></ul><p>提案，包括：发生顺序、某个键对应的值、谁是主节点…，比较宽泛</p><p>多节点系统最关键的是对多个事件的顺序进行共识，即排序</p><h2 id="相关概念">相关概念<a class="post-anchor" href="#相关概念"></a></h2><h3 id="共识">共识<a class="post-anchor" href="#共识"></a></h3><p><strong>在分布式系统中多个节点之间对某个事情达成一致看法的过程</strong></p><p><strong>所有节点对区块的同步</strong></p><h3 id="共识机制">共识机制<a class="post-anchor" href="#共识机制"></a></h3><p><strong>不同群体所寻求的共同的认识、价值、想法等，在某一方面达成的一致意见。 共识机制就是确定达成某种共识和维护共识的方式</strong></p><h3 id="拜占庭将军问题">拜占庭将军问题<a class="post-anchor" href="#拜占庭将军问题"></a></h3><p><strong>定义</strong></p><ul><li><p>一种分布式场景下的一致性问题</p><ul><li>叛徒少于1/3，问题可解</li></ul></li><li><p>莱斯利·兰波特在其论文[1]中描述了如下问题：</p><ul><li>一组拜占庭将军分别各率领一支军队共同围困一座城市。 为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。 因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。 因为各位将军分处城市不同方向，他们只能通过信使互相联系。 在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军， 这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</li></ul></li><li><p>系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。 假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。 这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。 这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。</p></li><li><p>由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。 而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。 因此很难通过保证人员可靠性及通讯可靠性来解决问题。</p></li><li><p>假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。 在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。</p></li><li><p>上述的故事映射到计算机系统里，将军便成了计算机，而信差就是通信系统。 虽然上述的问题涉及了电子化的决策支持与信息安全，却没办法单纯的用密码学与数字签名来解决。 因为电路错误仍可能影响整个加密过程，这不是密码学与数字签名算法在解决的问题。 因此计算机就有可能将错误的结果提交去，亦可能导致错误的决策。</p></li></ul><p><strong>拜占庭容错<br>ByzantineFaultTolerance</strong></p><ul><li><p>BFT</p></li><li><p>当失效节点不超过三分之一可达共识</p></li></ul><p><strong>拜占庭容错系统</strong></p><p><strong>共识算法</strong></p><ul><li><p>非拜占庭错误的情况</p><ul><li><p>Paxos</p><ul><li>基于分布式两阶段提交理论</li></ul></li><li><p>Raft</p></li></ul></li><li><p>容忍拜占庭错误的情况</p><ul><li><p>BFT</p><ul><li>PBFT</li></ul></li><li><p>POW</p></li><li><p>POS</p></li><li><p>DPOS</p></li></ul></li></ul><h3 id="错误">错误<a class="post-anchor" href="#错误"></a></h3><p><strong>拜占庭错误</strong></p><ul><li><p>Byzantine Fault Tolerance(BFT)</p></li><li><p>性能差，容忍不超过1/3的故障节点</p></li><li><p>PBFT（Practical BFT) 确定性系列算法</p><ul><li>不可逆，为最终结果</li></ul></li><li><p>PoW 概率算法</p><ul><li>临时结果，随时间推移或某种强化，被推翻的概率越小</li></ul></li><li><p>XFT（Cross Fault Tolerance)算法，提升处理速度</p></li><li><p>Algorand算法，实现更好的性能（1000+TPS）</p></li></ul><p><strong>故障错误</strong></p><ul><li><p>Crash Fault Tolerance(CFT)</p></li><li><p>性能好，容忍不超过1/2的故障节点</p></li><li><p>Paxos、Raft及变种算法</p></li></ul><h2 id="评价标准">评价标准<a class="post-anchor" href="#评价标准"></a></h2><p>资源消耗</p><h3 id="性能效率">性能效率<a class="post-anchor" href="#性能效率"></a></h3><p><strong>Pow</strong></p><ul><li>低</li></ul><p><strong>Pos</strong></p><ul><li>较高</li></ul><p><strong>DPoS</strong></p><ul><li>高</li></ul><p><strong>PBFT</strong></p><ul><li>高</li></ul><h3 id="扩展性">扩展性<a class="post-anchor" href="#扩展性"></a></h3><p><strong>对不同加密算法的支持</strong></p><p>安全性</p><h2 id="特点">特点<a class="post-anchor" href="#特点"></a></h2><h3 id="一致性">一致性<a class="post-anchor" href="#一致性"></a></h3><p><strong>分布式网络数据的一致性</strong></p><ul><li><p>一个公司内的分布式系统中的结点是被假设成可信任的</p></li><li><p>而在去中心化的网络下，所有结点要被假设成不可信任的</p></li><li><p>cap定理</p><ul><li>在一致性、可用性和分区容忍性上只能三选两。在区块链的 P2P 网络下也是很类似的，在去中心化、安全和高性能中，我们也只能选两个</li></ul></li></ul><p><strong>所有诚实节点保存的前缀一致</strong></p><h3 id="有效性">有效性<a class="post-anchor" href="#有效性"></a></h3><p><strong>由诚实节点发送的数据会达到其他诚实节点</strong></p><h2 id="区块链同步基本流程">区块链同步基本流程<a class="post-anchor" href="#区块链同步基本流程"></a></h2><p>发送节点将新的数据全网广播</p><p>接收节点对数据进行校验，数据记录纳入区块</p><p>全网所有接收节点对区块执行共识算法</p><p>区块通过共识后，纳入区块链存储。</p><h2 id="问题">问题<a class="post-anchor" href="#问题"></a></h2><h3 id="隔离见证">隔离见证<a class="post-anchor" href="#隔离见证"></a></h3><p><strong>交易和结算分开</strong></p><p><strong>原因是当前比特币确认时间过长</strong></p><ul><li>达到安全的状态需6个区块确认，约1小时</li></ul><h3 id="双花">双花<a class="post-anchor" href="#双花"></a></h3><p><strong>双重支付</strong></p><ul><li>同一个钱，用两次</li></ul><p><strong>理论上说，超过全网51%的算力，就能改账本，完成双花</strong></p><p><strong>预防双花</strong></p><ul><li>后面查资料看看呗</li></ul><h1 id="种类"><strong>种类</strong><a class="post-anchor" href="#种类"></a></h1><h2 id="公链">公链<a class="post-anchor" href="#公链"></a></h2><h3 id="工作量证明-Proof-of-Work，简称POW">工作量证明(Proof of Work，简称POW)<a class="post-anchor" href="#工作量证明-Proof-of-Work，简称POW"></a></h3><p><strong>定义</strong></p><ul><li><p>工作量证明</p></li><li><p>可简单理解为一份证明，证明你做过一定量的工作。<br>通过查看工作结果，就能知道你完成了指定量的工作。<br>区块链共识算法用的最多的就是POW。比特币和以太坊都是基于POW的共识机制。</p><ul><li><p>例</p><ul><li><p>比特币在区块的生成过程中使用的就是POW机制，</p></li><li><p>简单理解就是大家共同争夺记账权利，谁先抢到并正确完成记账工作，谁就得到系统的奖励，奖励为比特币，也就是所谓的“挖矿”。</p></li><li><p>矿工（参与挖矿的人）通过计算机的算力去完成这个记账工作，这个拥有计算能力的专业计算机就是所谓的“矿机”。</p></li></ul></li></ul></li><li><p>目前有很多数字资产用pow发行新币</p></li><li><p>开放性和匿名性，意味着任何节点可以随时进入这个网络， 即使是恶意节点。 </p></li><li><p>区块的生成和发送， 意味着对整个区块链状态的修改。 </p><ul><li><p>对状态的修改，必须要付出一定的成本， 这里面就是算力， 增大攻击的成本。</p><ul><li>……</li></ul></li></ul></li><li><p>在一个不可信的网络环境（节点不可信，网络不可信）下， 如何就状态，在不同的节点之间达成一致</p></li><li><p>新区块生成条件</p><ul><li><p>……</p><ul><li><p>要求 10 分钟一个区块， 2016 个区块的时间就是 2 个星期 ( 2016 * 10 * 60 / ( 24 * 60 * 60) = 14 days)</p></li><li><p>根据时间偏差来对应的调整难度值</p></li><li><p>调整幅度有最大/最小比例</p></li></ul></li></ul></li><li><p>比喻</p><ul><li><p>谁的算力大，谁就更大的几率做出记账</p><ul><li>举例子：比如生成的hash后面几位需要为0.你计算了多少次拿到了这个结果。</li></ul></li></ul></li></ul><p><strong>评价</strong></p><ul><li><p>特点</p><ul><li><p>1、算一道很难的题，系统给予挖矿奖励</p></li><li><p>2、多劳多得</p></li></ul></li><li><p>优点</p><ul><li><p>1、所有节点均可参与，记账权公平的分派到每个节点，去中心化</p></li><li><p>2、多劳多得，矿工积极性高</p></li><li><p>3、安全性高，欺诈成本高，如果能够欺诈成功，那么做诚实节点收益更大</p></li></ul></li><li><p>缺点</p><ul><li><p>1、主流矿池垄断严重，存在51%算攻击风险</p></li><li><p>2、浪费资源严重</p></li><li><p>3、持币人没有话语权，算力决定一切</p></li><li><p>4、网络性能低，共识时间长</p></li></ul></li></ul><p><strong>评价</strong></p><ul><li><p>优点</p><ul><li><p>完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。</p></li><li><p>只要网络破坏者的算力不超过全网总算力的50%，网络的交易状态就能达成一致，并不可篡改历史记录。</p></li><li><p>投入越多算力，获得记账权概率越大，越有可能产生新的区块奖励。</p></li></ul></li><li><p>缺点</p><ul><li><p>目前比特币挖矿造成大量的算力和能源浪费。</p></li><li><p>挖矿的激励机制也造成挖矿算力的高度集中</p><ul><li><p>随着算力的集中，渐渐向中心化演变</p><ul><li>算力集中于占据了大多数算力矿池</li></ul></li></ul></li><li><p>结算周期长，每秒最多结算7笔交易，不适合商业应用。</p></li></ul></li></ul><p><strong>POW – 农耕文明</strong></p><ul><li><p>需要“工作量证明”来声明新区块</p></li><li><p>pow：工作量证明，放弃了高性能</p><ul><li><p>挖矿：用大规模的计算来找到一个符合系统要求的区块 ID</p><ul><li>要找到符合条件的区块 ID 只能通过暴力穷举的方式，所以要付出大量的系统计算资源和电力。</li></ul></li><li><p>修改几乎变得不可能</p><ul><li>试想，如果生成一个区块需要大量的长时间的计算力。也就是在世界上最好的电脑集群下计算 10 分钟才能打好一个包，那么，当我们要去修改数据内容的时候，这个过程也是一样的。前面说过，如果你要伪造一个块，那么你就要修改后面所有的块，修改一个块的成本如此之高，那么修改整个链的成本也就非常之高了</li></ul></li><li><p>能掌握 51% 的算力的人也变得几乎不可能</p><ul><li>除了伪造一条链的成本很高，还要控制大多数人的算力，这意味着，是一个非常大的金钱的投入。这两个难度加起来，几乎不太可能。</li></ul></li><li><p>解决分歧</p><ul><li>一方面，这么大的工作量找出来的区块 ID，已经有效地降低了大家有意见冲突的概率。<br>另一方面，就算是出现了合法冲突的区块（同时出现了多个合理的区块，即区块链出现分支 / 分叉），也就是多个合法的账本。而因为挖矿的成本太高，导致要同时跟进多个账本是不可能的，所以矿工们只能赌跟其中一个。<br>大多数人所选择的那一个分支的链就会越来越多，于是另外一边也就无人问津，从而作废了。</li></ul></li><li><p>pow机制存在的问题</p><ul><li><p>越来越中心化地记账</p></li><li><p>越来越跑不动</p></li></ul></li></ul></li></ul><p><strong>工作量证明机制：pow</strong></p><ul><li><p>工作量证明机制即对于工作量的证明，<br>是生成要加入到区块链中的一笔新的交易信息(即新区块)时必须满足的要求。</p></li><li><p>在基于工作量证明机制构建的区块链网络中，节点通过计算随机哈希散列的数值解争夺记账权，求得正确的数值解以生成区块的能力是节点算力的具体表现。<br>工作量证明机制具有完全去中心化的优点，在以工作量证明机制为共识的区块链中，节点可以自由进出。</p></li><li><p>大家所熟知的比特币网络就应用工作量证明机制来生产新的货币。<br>然而，由于工作量证明机制在比特币网络中的应用已经吸引了全球计算机大部分的算力，其他想尝试使用该机制的区块链应用很难获得同样规模的算力来维持自身的安全。<br>同时，基于工作量证明机制的挖矿行为还造成了大量的资源浪费，达成共识所需要的周期也较长，因此该机制并不适合商业应用。</p></li></ul><p><strong>工作量证明（POW）</strong></p><ul><li><p>问题</p><ul><li>公地悲剧问题</li></ul></li></ul><p><strong>使用项目</strong></p><ul><li>比特币、以太坊、比原链等</li></ul><p><strong>其他</strong></p><ul><li><p>原理</p><ul><li>通过找到合理随机数争夺记账权</li></ul></li></ul><h3 id="权益证明-Proof-of-Stake，简称POS">权益证明(Proof of Stake，简称POS)<a class="post-anchor" href="#权益证明-Proof-of-Stake，简称POS"></a></h3><p><strong>定义</strong></p><ul><li><p>通过持有Token（代币）的数量和时长来决定你获得记账的机率，<br>类似于股票的分红制度，持有股权越多的人就能够获得更多的分红。<br>Token相当于区块链系统的权益。</p></li><li><p>2012年，化名Sunny King的网友推出了Peercoin，该加密电子货币采用工作量证明机制发行新币，<br>采用权益证明机制维护网络安全，这是权益证明机制在加密电子货币中的首次应用。</p><ul><li><p>与要求证明人执行一定量的计算工作不同，权益证明要求证明人提供一定数量加密货币的所有权即可。</p></li><li><p>权益证明机制的运作方式是：</p><ul><li>当创造一个新区块时，矿工需要创建一个“币权”交易，交易会按照预先设定的比例把一些币发送给矿工本身。<br>权益证明机制根据每个节点拥有代币的比例和时间，依据算法等比例地降低节点的挖矿难度，从而加快了寻找随机数的速度。<br>这种共识机制可以缩短达成共识所需的时间，但本质上仍然需要网络中的节点进行挖矿运算。<br>因此，PoS机制并没有从根本上解决PoW机制难以应用于商业领域的问题。</li></ul></li></ul></li><li><p>随着代币的集中，渐渐向中心化演变</p></li><li><p>需要“财产证明”来声明新区块</p><ul><li>根据持有数字货币的数量与时间，进行利息发放和区块产生的机制</li></ul></li><li><p>比喻</p><ul><li><p>谁有的区块链资产多大，谁就更大的几率做记账</p></li><li><p>资本主义模式，钱越多，责任越多</p></li></ul></li></ul><p><strong>评价</strong></p><ul><li><p>优点</p><ul><li><p>降低了PoW机制的资源浪费。</p></li><li><p>加快了运算速度，也可以理解为工作量证明的升级版</p></li></ul></li><li><p>缺点</p><ul><li>拥有币龄越长的节点获得记账权的几率越大，<br>容易导致马太效应，富者越富，权益会越来越集中,从而失去公正性。</li></ul></li></ul><p><strong>POS – 资本主义</strong></p><ul><li><p>pos：股权证明，放弃了安全</p><ul><li><p>在 PoS 机制下，矿工不在叫矿工，而是叫 Validator（校验者）</p></li><li><p>pow 好像是 “ 多劳多得 “ 的社会，而 pos 更像是 “ 资本主义 “ 社会，钱越多的人越有话语权</p></li><li><p>pos的好处</p><ul><li><p>不需要那么费劲的挖矿了。那样浪费电力不环保地挖矿的确有点太糟糕了。PoS 很明显地解决了这个问题。</p></li><li><p>在 PoS 下，你需要有 51% 的财富，你才可以发起攻击，这相对于算力而言需要更多的成本。 设想一下，你得拥有 51% 的比特币，你才能黑了比特币，然而，如果你有 51% 的财富，你为什么要黑了这个系统，自己把自己干死呢？</p></li></ul></li><li><p>pos潜在的问题</p><ul><li>双重支付的问题</li></ul></li></ul></li></ul><p><strong>3、POS(股权证明)</strong></p><ul><li><p>特点</p><ul><li><p>1、不挖矿，依靠币龄(币持有数量 * 持有天数)决定记账权，利息即为奖励，记账后币龄清零</p></li><li><p>2、按钱分配，钱生钱</p></li></ul></li><li><p>优点</p><ul><li><p>1、在一定程度上缩短了共识达成的时间</p></li><li><p>2、节约资源</p></li><li><p>3、防作弊，币龄越大，获得记账权几率越大、避免51%攻击，会因为攻击会使自己权益受损</p></li></ul></li><li><p>缺点</p><ul><li>1、数字货币过于集中化，富者越来越富有，散户参与积极性低</li></ul></li><li><p>项目</p><ul><li>ADA等</li></ul></li></ul><h3 id="委托权益证明-Delegated-Proof-of-Stake，简称DPOS">委托权益证明(Delegated Proof of Stake，简称DPOS)<a class="post-anchor" href="#委托权益证明-Delegated-Proof-of-Stake，简称DPOS"></a></h3><p><strong>概述</strong></p><ul><li><p>股份授权证明机制</p><ul><li>Delegated Proof Of Stake</li></ul></li><li><p>股份授权证明机制是一种新的保障网络安全的共识机制。<br>它在尝试解决传统的PoW机制和PoS机制问题的同时，<br>还能通过实施科技式的民主抵消中心化所带来的负面效应。</p><ul><li><p>股份授权证明机制与董事会投票类似，该机制拥有一个内置的实时股权人投票系统，就像系统随时都在召开一个永不散场的股东大会，所有股东都在这里投票决定公司决策。<br>基于DPoS机制建立的区块链的去中心化依赖于一定数量的代表，而非全体用户。<br>在这样的区块链中，全体节点投票选举出一定数量的节点代表，由他们来代理全体节点确认区块、维持系统有序运行。<br>同时，区块链中的全体节点具有随时罢免和任命代表的权力。如果必要，全体节点可以通过投票让现任节点代表失去代表资格，重新选举新的代表，实现实时的民主。</p></li><li><p>股份授权证明机制可以大大缩小参与验证和记账节点的数量，从而达到秒级的共识验证。<br>然而，该共识机制仍然不能完美解决区块链在商业中的应用问题，因为该共识机制无法摆脱对于代币的依赖，而在很多商业应用中并不需要代币的存在。</p></li></ul></li><li><p>用户票选代理人。由代理人轮流生成新区块</p></li><li><p>代理人相互制约，确保不会伪造</p></li><li><p>类似董事会投票机制</p></li><li><p>代理权益证明，放弃了去中心化</p><ul><li><p>DPoS 已经开始把区块链的去中心化的初衷开始向中心化的地方演进了</p></li><li><p>DPoS 就是政治主义社会。<br>谁的选票多谁说话，但是感觉又回到了中心化架构中的 Leader 选举</p></li></ul></li><li><p>是基于POS衍生出的更专业的解决方案，类似于董事会投票，指拥有Token的人投票给固定的节点，选举若干代理人，由代理人负责验证和记账。<br>不同于POW和POS的全网都可以参与记账竞争，DPOS的记账节点在一定时间段内是确定的</p></li><li><p>通过不同的策略，不定时地选中一小群节点，这一小群节点做新区块的创建、验证、签名和相互监督。<br>这样就大幅度减少了区块创建和确认所需要消耗的时间和算力成本。</p></li><li><p>比喻</p><ul><li>每个有币节点投票，产生100名候选人。随机选取一个股东来产生区块。轮流记账</li></ul></li></ul><p><strong>评价</strong></p><ul><li><p>特点</p><ul><li><p>不挖矿</p></li><li><p>每年按比例增发代币</p></li><li><p>奖励超级节点</p></li></ul></li><li><p>优点</p><ul><li><p>相较pow，dpos大幅提高区块链处理数据的能力，甚至可以实现秒到账，同时也大幅降低维护区块链网络安全的费用</p></li><li><p>高效、扩展性强</p></li></ul></li><li><p>缺点</p><ul><li><p>去中心程度较弱，节点代理是人为选出的，公平性相比POS较低，依赖于代币的增发来维持代理节点的稳定性</p></li><li><p>21个节点太少，非去中心化，而是多中心化</p></li></ul></li></ul><p><strong>项目</strong></p><ul><li>EOS</li></ul><p><strong>其他</strong></p><ul><li>DPOS – 社会主义</li></ul><h2 id="联盟链">联盟链<a class="post-anchor" href="#联盟链"></a></h2><h3 id="实用拜占庭容错算法（Practical-Byzantine-Fault-Tolerance，简称PBFT）">实用拜占庭容错算法（Practical Byzantine Fault Tolerance，简称PBFT）<a class="post-anchor" href="#实用拜占庭容错算法（Practical-Byzantine-Fault-Tolerance，简称PBFT）"></a></h3><p><strong>概述</strong></p><ul><li><p>Practical Byzantine Fault Tolerance</p></li><li><p>PBFT，是联盟币的共识算法的基础。</p></li><li><p>实现了在有限个节点的情况下的拜占庭问题，有3f+1的容错性，并同时保证一定的性能。</p></li><li><p>该算法在保证活性和安全性的前提下提供了（n-1）/3的容错性。<br>主要实现的有拜占庭容错的NFS文件系统。</p></li></ul><p><strong>应用</strong></p><ul><li><p>联盟链和私有链</p><ul><li>Hyperledger组织下的Fabric项目使用的是该算法</li></ul></li></ul><h2 id="私链">私链<a class="post-anchor" href="#私链"></a></h2><h3 id="验证池共识机制Pool">验证池共识机制Pool<a class="post-anchor" href="#验证池共识机制Pool"></a></h3><p><strong>定义</strong></p><ul><li><p>Pool验证池</p></li><li><p>Pool验证池基于传统的分布式一致性技术建立，并辅之以数据验证机制，是目前区块链中广泛使用的一种共识机制。</p><ul><li>基于传统的分布式一致性技术，加上数据验证机制，是目前行业链大范围在使用的共识机制。</li></ul></li><li><p>Pool验证池不需要依赖代币就可以工作，在成熟的分布式一致性算法(Pasox、Raft)基础之上，<br>可以实现秒级共识验证，更适合有多方参与的多中心商业模式。<br>不过，Pool验证池也存在一些不足，例如该共识机制能够实现的分布式程度不如PoW机制等。</p></li></ul><p><strong>评价</strong></p><ul><li><p>优点</p><ul><li><p>不需要依赖代币也可以实现秒级共识验证</p><ul><li>不需要代币也可以工作，在成熟的分布式一致性算法（Pasox,Raft）基础上实现秒级共识验证。</li></ul></li></ul></li><li><p>缺点</p><ul><li><p>去中心化程度弱，更适合多方参与的多中心商业模式</p><ul><li>去中心化程度不如bitcoin，适合多中心的商业模式</li></ul></li></ul></li></ul><h3 id="paxos">paxos<a class="post-anchor" href="#paxos"></a></h3><p><strong>概述</strong></p><ul><li><p>Paxos算法是莱斯利・兰伯特( Leslie Lamport,现就职于微软研究院)于1990年提出的，是一种基于消息传递的一致性算法。<br>莱斯利・兰伯特于2013年获得了图灵奖。他的分布式计算理论莫定了这门学科的基础。</p></li><li><p>菜斯利・兰伯特在1978年发表了论文《分布式系统内的时间、时钟事件顺序》(Time, Clocks, and the Ordering of Events in a Distributed System),<br>这篇论文成为目前计算机科学史上被引用最多的文献。他的论文为并发系统的规范与验证课题的研究贡献了核心原理。</p></li><li><p>Paxos算法是在莱斯利・兰伯特的论文 The Part- Time Parliamen中提出的。<br>在论文中，他以故事的方式讲述了 Paxos算法</p><ul><li><p>古希腊有一个叫 Paxos的岛屿，是爱琴海上的一个小島， Paxos是一个兴盛的商业贸易中心。<br>在这个岛屿上，法律的制定与修订通过议会表决的形式进行，而非传统的神权治。</p></li><li><p>所有法律都必须经由议会成员授票表决后才能生效实范，而且已通过的律法必须被记录在案。</p></li><li><p>在岛上，商业繁荣，做生意赚钱才是头等大事，因此没有人愿意始终在议会大斤里从头到尾参与每一个法律表决的会议。<br>为此，每一个议员都来维护一个法律律簿，用来记录一系列已通过的法令，每个法令带有一个唯编号。<br>为了保持各个议员法律律薄内容的一致性，法律律簿是用擦不掉的墨水书写而成的，所以内容一旦书写就不能改变。</p></li><li><p>在议会中有多个角色的成员：议员和服务员。<br>服务员的工作是在比较曹杂的议会厅里传递信息，议员的工作是发起法律提案或将通过的法律记录在自己的法律律簿上。</p></li><li><p>由于议员和服务员有可能并不可靠，他们可能随时会因为各种事情临时甚至是彻底离开议会大斤，服务员也有可能重复传递消息，<br>当然也可能有新的议员在临时事务处理完毕后再回到议会大厅进行法律表决，<br>因此议会的协议要求保证在上述情况下能够正确地修订法律并且不会产生冲突。</p></li><li><p>在法律表决时，议员的角色分为 proposers和 acceptors</p></li><li><p>通过一个法律决议时，分为两个阶段：</p><ul><li><p>阶段1: prepare阶段</p><ul><li><p>proposer选择一个提案编号n,并将 prepare请求发送给 acceptors群体。</p></li><li><p>acceptor收到 prepare消息后，如提案的编号大于它已经回复的所有prepare消息，<br>则 acceptor将自己上次接受的提案回复给 proposer,并承诺不再回复小于n的提案；<br>如果提案的编号小于等于它已经回复的所有 prepare消息，则说明是重复消息，不再重复处理。</p></li></ul></li><li><p>阶段2:批准阶段</p><ul><li>当 proposer收到多数 acceptors对 prepare的回复后，就进入批准阶段。<br>它要向回复 prepare请求的 acceptors发送 accept请求。<br>acceptor收到accept请求后，则立即接受这个请求。</li></ul></li></ul></li></ul></li><li><p>Paxos 问题是指分布式的系统中存在故障（crash fault），但不存在恶意（corrupt）节点的场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。<br>解决分布式系统中一致性问题的共识算法（Consensus Algorithm），其最基本的功能是为了在多个进程之间对某个值达成一致。<br>通过这个最基本功能，就可以在多个进程之间进行数据库、状态机、账本（区块链）等对象的同步。<br>被广泛应用在 Chubby、ZooKeeper 这样的分布式系统中。类似于两阶段提交算法</p></li></ul><p><strong>基本原理</strong></p><ul><li><p>三个角色</p><ul><li><ol><li>Proposer。<br>提案者，用于提出议案，提案的内容为：令 x=value，对同一轮提案，最多提议一个value </li></ol></li><li><ol start="2"><li>Acceptor。<br>投票者，完全对等，在独立的时间轴执行提案投票</li></ol></li><li><ol start="3"><li>Learner。<br>学习者，一个提案超过半数accpetor通过即可被chosen，其他未确定的Acceptor可以通过learner来同步结果</li></ol></li></ul></li><li><p>两阶段</p><ul><li><ol><li><p>Prepare阶段</p><ul><li><p>1.Proposer选择一个提案编号N，向所有的Acceptor广播Prepare(N)请求</p></li><li><p>2.Acceptor收到Prepare(N)请求，若提案编号N比之前接收的Prepare请求都要大，则承诺(Promise，将N记录下来)将不会接收提案编号比N小的提议，<br>并且带上之前Accept的提议中编号小于N的最大的提案value(没有则为NULL)。如果N比之前接受的提案编号小，则不予理会。</p></li></ul></li></ol></li><li><ol start="2"><li><p>Proposal阶段</p><ul><li><p>1.Proposer收到Acceptor的Promise。</p><ul><li><p>如果未超过半数的Accpetor回复承诺(Promise)则本次提案失败；</p></li><li><p>如果超过半数的Acceptor回复承诺，又分为不同情况：</p><ul><li><p>如果(回复承诺的)所有Acceptor都未接收过value(都为null)，<br>那么向所有的Acceptor发起(Propose)自己的value和提案编号N。</p></li><li><p>如果有部分Acceptor接收过value，那么从接受过的value中选择提案编号N最大对应的value作为本次提案的value，<br>提议编号仍然为N(此时Proposer不能提议自己的value，只能信任Acceptor通过的value，以达成收敛的效果)</p></li></ul></li></ul></li><li><p>2.Acceptor接收到Proposal后，如果该提案编号N不等于自身当前承诺的编号(第一阶段记录的)，<br>不接受该请求，相等则将提案的value写入本地</p></li></ul></li></ol></li></ul></li><li><p>理解</p><ul><li><p>分布式抢占锁</p><ul><li><p>Prepare阶段–申请加锁，Proposal阶段–修改并释放锁</p></li><li><p>只有超过半数的Acceptor同意，加锁才成功；<br>否则可能存在多个申请加锁的客户端</p></li><li><p>每个Proposer都可能失效，独占锁机制下获得独占锁定权的Proposer失效会导致死锁</p></li><li><p>提案编号由Proposer自己维护，一般采用递增机制且全局唯一。<br>这样就可以对提案进行全局排序，只有提案编号高的(最新)的提案被接受，避免了死锁</p></li></ul></li></ul></li></ul><p><strong>文章</strong></p><ul><li><p><a href="https://www.jianshu.com/p/ddf0db5d5f52" target="_blank" rel="noopener">https://www.jianshu.com/p/ddf0db5d5f52</a></p></li><li><p><a href="https://www.chainnode.com/post/220369" target="_blank" rel="noopener">https://www.chainnode.com/post/220369</a></p></li></ul><h3 id="raft">raft<a class="post-anchor" href="#raft"></a></h3><p><strong>定义</strong></p><ul><li><p>raft是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。在这里强调了是在工程上，因为在学术理论界，最耀眼的还是大名鼎鼎的Paxos。<br>但Paxos是：少数真正理解的人觉得简单，尚未理解的人觉得很难，大多数人都是一知半解。<br>本人也花了很多时间、看了很多材料也没有真正理解。直到看到raft的论文，两位研究者也提到，他们也花了很长的时间来理解Paxos，他们也觉得很难理解，于是研究出了raft算法。</p></li><li><p>raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下。<br>这些年最为火热的加密货币（比特币、区块链）就需要共识算法，而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），<br>在带着问题学习分布式系统之中心化复制集一文中介绍了中心化复制集的相关知识。<br>raft协议就是一种leader-based的共识算法，与之相应的是leaderless的共识算法。</p></li><li><p>Raft算法的头号目标就是容易理解（UnderStandable），这从论文的标题就可以看出来。<br>当然，Raft增强了可理解性，在性能、可靠性、可用性方面是不输于Paxos的。</p><ul><li><p>Raft more understandable than Paxos and also provides a better foundation for building practical systems</p></li><li><p>为了达到易于理解的目标，raft做了很多努力，其中最主要是两件事情：</p><ul><li><p>问题分解</p></li><li><p>状态简化</p></li></ul></li></ul></li><li><p>问题分解是将”复制集中节点一致性”这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。<br>在raft，子问题包括，leader election， log replication，safety，membership changes。<br>而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性<br>（比如，保证新选举出来的leader会包含所有commited log entry）</p></li><li><p>Raft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for managing the replicated log.<br>The leader accepts log entries from clients,replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines.<br>A leader can fail or become disconnected from the other servers, in which case a new leader is elected.</p></li><li><p>上面的引文对raft协议的工作原理进行了高度的概括：<br>raft会先选举出leader，leader完全负责replicated log的管理。<br>leader负责接受所有客户端更新请求，然后复制到follower节点，并在“安全”的时候执行这些请求。<br>如果leader故障，followes会重新选举出新的leader。</p></li><li><p>Raft 通过远程过程调用(RPC)来实现节点间的通信, 定义了下面几种 RPC:</p><ul><li><p>RequestVote RPC: 由 candidate 调用, 用于进行 leader 选举.</p></li><li><p>AppendEntries RPC: 由 leader 调用, 用于复制日志或作为心跳信息(维持leader).</p></li></ul></li></ul><p><strong>这就涉及到raft最新的两个子问题</strong></p><ul><li><p>leader election</p><ul><li><p>相关概念</p><ul><li><p>term</p><ul><li><p>任期</p><ul><li><p>从上面可以看出，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。<br>这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫term。</p></li><li><p>……</p></li><li><p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。<br>从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；<br>另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。</p></li></ul></li></ul></li></ul></li><li><p>选举过程详解</p><ul><li><p>上面已经说过，如果follower在election timeout内没有收到来自leader的心跳，<br>（<br>也许此时还没有选出leader，大家都在等；<br>也许leader挂了；<br>也许只是leader与该follower之间网络故障<br>）<br>，则会主动发起选举。</p></li><li><p>步骤如下：</p><ul><li><p>增加节点本地的 current term ，切换到candidate状态</p></li><li><p>投自己一票</p></li><li><p>并行给其他节点发送 RequestVote RPCs</p></li><li><p>等待其他节点的回复</p></li></ul></li><li><p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p><ul><li><p>收到majority的投票（含自己的一票），则赢得选举，成为leader</p><ul><li><p>第一种情况，赢得了选举之后，新的leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。<br>在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：</p><ul><li><p>在任一任期内，单个节点最多只能投一票</p></li><li><p>候选人知道的信息不能比自己的少<br>（这一部分，后面介绍log replication和safety的时候会详细介绍）</p></li><li><p>first-come-first-served 先来先得</p></li></ul></li></ul></li><li><p>被告知别人已当选，那么自行切换到follower</p><ul><li>第二种情况，比如有三个节点A B C。<br>A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。<br>A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。</li></ul></li><li><p>一段时间内没有收到majority投票，则保持candidate状态，重新发出选举</p><ul><li><p>第三种情况，没有任何节点获得majority投票，比如下图这种情况：</p></li><li><p>……</p></li><li><p>总共有四个节点，Node C、Node D同时成为了candidate，进入了term 4，但Node A投了NodeD一票，NodeB投了Node C一票，这就出现了平票 split vote的情况。<br>这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间（没有leader是不能处理客户端写请求的），<br>因此raft引入了randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。</p></li></ul></li></ul></li></ul></li></ul></li><li><p>log replication</p><ul><li><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤：</p></li><li><p>请求完整流程</p><ul><li><p>leader append log entry</p></li><li><p>leader issue AppendEntries RPC in parallel</p></li><li><p>leader wait for majority response</p></li><li><p>leader apply entry to state machine</p></li><li><p>leader reply to client</p></li><li><p>leader notify follower apply log</p></li></ul></li></ul></li></ul><p><strong>性质</strong></p><ul><li><p>Election Safety:</p><ul><li>最多只有一个节点成为 Leader.</li></ul></li><li><p>Leader Append-Only:</p><ul><li>Leader 不会删除或覆盖自身的日志, 只会不断将新的日志附加到日志末尾.</li></ul></li><li><p>Log Matching:</p><ul><li>如果两条日志(log entry)的term和index相同, 那么从这两条日志开始, 她们和她们前面的所有日志都对应相同.</li></ul></li><li><p>Leader Completeness:</p><ul><li>如果一条日志在一个 term 中被 commit 了,<br>那么在该 term 之后的所有 term 中, 这些 term 的 Leader 的日志中都包含这条日志.</li></ul></li><li><p>State Machine Safety:</p><ul><li>如果一个节点应用了一条日志到状态机, 那么其他机器不会应用一个 index 与此日志相同, 内容却不同的日志到状态机.<br>也就是说, 对于不同节点应用到状态机的日志, 只要 index 相同, 日志就是相同的.</li></ul></li></ul><h3 id="POA">POA<a class="post-anchor" href="#POA"></a></h3><p><strong>定义</strong></p><ul><li><p>POA(Proof of Activity)</p><ul><li>行动证明</li></ul></li><li><p>链上节点相互信任</p></li><li><p>授权证明（PoA）是PoS一致性算法的子集，主要由测试网和私有或联盟网络使用。<br>在基于PoA的区块链中，交易有效性最终由一组经批准的链上账户确定，称为“授权节点”。<br>确定授权节点的标准是通过网络治理结构中编写的方法确定性地决定的。</p></li><li><p>PoA被广泛认为是达成共识的最快途径，但依赖于验证节点尚未受到损害的假设。<br>非验证参与者可以像公共以太网那样访问和使用网络（通过利用p2p交易，合约，账户等）</p></li><li><p>PoA共识依赖于验证者的声誉和过去的表现。这个想法是验证者节点将其身份/声誉放到我的身上。<br>私人联盟网络的一个重要方面是链上地址与已知的现实世界身份之间的联系。<br>因此，我们可以说验证节点正在盯着他们的“身份”或“声誉”（而不是他们的经济持有）。<br>这为验证者创建了一定程度的问责制，最适合企业，私有或测试网络。</p></li><li><p>PoA目前由测试网络Kovan（PoA网络）使用，并且可以在Parity中轻松配置用于私人联盟网络。</p></li><li><p>Combine Proof of Work component with a Proof of Stake.</p></li><li><p>mining first begins in the traditional manner, with miners vying to be the first to solve a puzzle and claim their reward.<br>The difference is that the blocks being mined do not contain transactions.<br>They are simply templates with header information and the mining reward address.<br>Once this nearly blank block is mined, the system switches to a proof of stake protocol.<br>The header information is used to select a random group of validators to sign the block.<br>These are coin holders (stakeholders) and the larger the stake a validator holds, the greater the chance they will be selected to sign the new block.<br>Once all the chosen validators sign the block it becomes an actual part of the blockchain.<br>If the block remains unsigned by some of the chosen validators after a given time, it is discarded as incomplete and the next winning block is used.<br>Validators are once again chosen and this continues until a winning block is signed by all the chosen validators.<br>The network fees are split between the winning miner and the validators who signed the block.</p></li></ul><p><strong>其他</strong></p><ul><li>POA – 共产主义</li></ul><h2 id="其他">其他<a class="post-anchor" href="#其他"></a></h2><h3 id="ripple">ripple<a class="post-anchor" href="#ripple"></a></h3><p><strong>瑞波币</strong></p><p>小蚁共识</p><h1 id="总结"><strong>总结</strong><a class="post-anchor" href="#总结"></a></h1><p>每一种共识机制都不能同时满足安全、效率、公平。 去中心程度越弱，安全性就越低，区块链的速度就越快； 去中心化程度越强，安全性就会越高，区块链的速度就会越慢。</p><p>POW完全去中心化，但运行效率太低。 POS提高了效率，但却降低了公平与安全。 DPOS有强烈的中心化特性，却在短期内效率最高。</p><p>目前行业区块链大范围使用Pool共识。</p><h1 id="其他-1"><strong>其他</strong><a class="post-anchor" href="#其他-1"></a></h1><h2 id="问题与挑战">问题与挑战<a class="post-anchor" href="#问题与挑战"></a></h2><ol><li><p>如何提出一个待共识的提案？如通过令牌传递、随机选取、权重比较、求解难题…</p></li><li><p>如何让多个节点对该提案达成共识（同意或拒绝），如投票、规则验证…</p></li></ol><p>故障节点：非拜占庭节点 恶意节点：拜占庭节点 非拜占庭场景的典型例子是通过报数来统计人数，即便偶有冲突（如两人同时报一个数）也能很快解决； 拜占庭场景的一个常见例子是“杀人游戏”，当参与者众多时很难快速达成共识。</p><h2 id="共识机制（数据同步）">共识机制（数据同步）<a class="post-anchor" href="#共识机制（数据同步）"></a></h2><h3 id="特性">特性<a class="post-anchor" href="#特性"></a></h3><p><strong>少部分写，多读</strong></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;以下为-mindmanager-的预览&quot;&gt;以下为 mindmanager 的预览&lt;a class=&quot;post-anchor&quot; href=&quot;#以下为-mindmanager-的预览&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;div cl
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="导图" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/%E5%AF%BC%E5%9B%BE/"/>
    
    
      <category term="区块链" scheme="http://takostar.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>区块链的种类</title>
    <link href="http://takostar.net/2022/02121133/"/>
    <id>http://takostar.net/2022/02121133/</id>
    <published>2022-02-12T03:33:34.000Z</published>
    <updated>2022-02-26T16:21:38.461Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><!-- TODO:实现搜索框的按键展示(使用页面缩放?或者是弹性相应和直接style) --><div class="post-mindmap">  <iframe class="mindmap" id="mindmap" src="区块链 - 分类.html"></iframe>  <div class="r">  <span class="iconfont icon-close"></span>    <div class="tip"></div>    <a class="fullscreen-button">Full Screen</a></div></div>  <script type="text/javascript">    var sonWidth = document.getElementById("mindmap").offsetWidth;    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";</script><h1 id="概述"><strong>概述</strong><a class="post-anchor" href="#概述"></a></h1><p>……</p><h1 id="按应用范围"><strong>按应用范围</strong><a class="post-anchor" href="#按应用范围"></a></h1><h2 id="公有链">公有链<a class="post-anchor" href="#公有链"></a></h2><h3 id="概念">概念<a class="post-anchor" href="#概念"></a></h3><p><strong>公链（public blockchain）</strong></p><ul><li><p>公有区块链</p></li><li><p>公有（Public）链</p></li></ul><p><strong>世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。</strong></p><p><strong>公链，是指全世界任何人都可读取、发送交易且能获得有效确认的共识区块链。公链的安全由工作量证明机制（pow）或权益证明机制(pos)等方式负责维护。 它们是以经济奖励与加密数字验证相结合的方式而存在的，并遵循着一般原则：每个人从中可获得的经济奖励，与对共识过程作出的贡献成正比。 这些区块链通常被认为是“完全去中心化”的</strong></p><p><strong>公有区块链是最早的区块链，也是应用最广泛的区块链， 各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上有且仅有一条该币种对应的区块链。</strong></p><h3 id="特点">特点<a class="post-anchor" href="#特点"></a></h3><p><strong>所有人可以随时自带的加入和退出，每个节点平等，都有权交易和记账，属于开放式</strong></p><h3 id="代表">代表<a class="post-anchor" href="#代表"></a></h3><p><strong>比特币</strong></p><ul><li>Bitcoin</li></ul><p><strong>以太坊</strong></p><ul><li>Ethereum</li></ul><p><strong>EOS</strong></p><p><strong>NEO</strong></p><p><strong>量子链</strong></p><p><strong>比原链</strong></p><p><strong>井通链</strong></p><p><strong>Hyperledger</strong></p><p><strong>TRON</strong></p><h2 id="联盟链">联盟链<a class="post-anchor" href="#联盟链"></a></h2><h3 id="概述-1">概述<a class="post-anchor" href="#概述-1"></a></h3><p><strong>联盟（Consortium）链</strong></p><ul><li><p>联合（行业）区块链</p></li><li><p>共同体区块链 （Consortium blockchains）</p></li></ul><p><strong>由某个群体内部指定多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程）， 其他接入节点可以参与交易，但不过问记账过程 (本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点）， 其他任何人可以通过该区块链开放的API进行限定查询；</strong></p><p><strong>我们在前面的文章介绍过它。所谓联盟链，就是这个区块链具有准入许可，不像公链，任何人都可以随时进入。<br>准入许可也就意味着候选节点进入区块链时需要得到已经在网络中的节点许可，所以联盟链也叫做许可链。</strong></p><p><strong>共同体区块链，是指其共识过程受到预选节点控制的区块链；</strong></p><ul><li>例如，有15个金融机构组成一个共同体，每个机构都运行着一个节点，而且为了使每个区块生效需要获得其中10个机构的确认。 区块链或许允许每个人都可读取，或者只受限于参与者，或走混合型的路线， 例如区块的根哈希及其API（应用程序接口）对外公开，API可允许外界用来作有限次数的查询和获取区块链状态的信息。 这些区块链可视为“部分去中心化”</li></ul><h3 id="特点-1">特点<a class="post-anchor" href="#特点-1"></a></h3><p><strong>仅部分人参与，加入和退出需要授权，选定某些节点为记账人，其他人可以交易，但无记账权，属于半封闭式</strong></p><h3 id="代表-1">代表<a class="post-anchor" href="#代表-1"></a></h3><p><strong>R3CEV，全球40多个银行成立的联盟组织，2017年7月成立，共享区块链技术</strong></p><p><strong>IBM fabric项目</strong></p><ul><li>超级账本Fabric</li></ul><p><strong>Linux基金会发起的超级账本(HyperLedger)项目，2015年成立，fabric是子项目</strong></p><p><strong>如银行联盟，搭建转账系统</strong></p><h2 id="私有链">私有链<a class="post-anchor" href="#私有链"></a></h2><h3 id="概述-2">概述<a class="post-anchor" href="#概述-2"></a></h3><p><strong>私有（Private）链</strong></p><ul><li><p>私有区块链</p></li><li><p>私链（private blockchain)，又称无代币区块链（Token-less blockchain）</p></li></ul><p><strong>如果是私有的，有比区块链成本更低的解决方案</strong></p><p><strong>完全私有的区块链 , 是指其写入权限仅在一个组织手里的区块链。<br>读取权限或者对外开放，或者被任意程度地进行了限制。<br>相关的应用囊括数据库管理、审计、甚至一个公司，但在很多的情形下，公共的可读性并非是必须的。</strong></p><p><strong>关于没有原生代币的系统，是否能被称为区块链，仍然有着很大的争议。<br>一些人认为，没有代币的区块链，可以一种分布式多版本并发控制(MVCC)数据库的形式而存在。<br>多版本并发控制，可防止两笔交易在数据库中修改一个单一列，而区块链，则是阻止两笔交易在区块链中的单个输出（ output）。</strong></p><h3 id="特点-2">特点<a class="post-anchor" href="#特点-2"></a></h3><p><strong>公司内部使用，可以更好的实现权限控制：管理和审计，属于封闭式</strong></p><h3 id="代表-2">代表<a class="post-anchor" href="#代表-2"></a></h3><p><strong>如企业内部链</strong></p><h1 id="按部署机制"><strong>按部署机制</strong><a class="post-anchor" href="#按部署机制"></a></h1><h2 id="主链">主链<a class="post-anchor" href="#主链"></a></h2><p>主网</p><h2 id="测试链">测试链<a class="post-anchor" href="#测试链"></a></h2><p>测试网</p><h1 id="按对接类型"><strong>按对接类型</strong><a class="post-anchor" href="#按对接类型"></a></h1><h2 id="侧链">侧链<a class="post-anchor" href="#侧链"></a></h2><h3 id="概述-3">概述<a class="post-anchor" href="#概述-3"></a></h3><p><strong>如闪电网络，用于解决比特币区块链确认过久的问题</strong></p><p><strong>侧链是一种双向挂钩技术，将主链中的代币锁定到側链中使用。<br>所以可以将主链看作主干道，侧链看作与主链相对独立的一条分支道，作为主链功能的低耦合拓展</strong></p><h3 id="如何实现">如何实现<a class="post-anchor" href="#如何实现"></a></h3><p><strong>公证人机制（Notary schemes）</strong></p><ul><li><p>第一种是有一组同时承担两条链节点的个人或联盟，也有可能是一条单独的链，告诉 B 链 A 链上发生什么事，或者告诉 B 某个消息的真的。<br>比如 Ripple 开发的跨账本价值传输开放协议 Interledger，但它不是链，只是一套网关协议。V 神把这种称为公证人模式（Notary schemes）。</p></li><li><p>公证人机制（Notary schemes）：三种方式中最为简单，目前使用的也是比较多的一种方式，举下例子：PBFT协议中，每个节点都是一个公证人，那么你从节点中获得超过三分之二的节点签名，那么就表示这个公证是有效的。<br>或者，在实现锚锭侧链的时候，主链发送交易到侧链时候所拥有的一个多重签名地址，然后需要花费这个交易的时候必须同时提供8-of-10的multisig的签名才是有效。现在使用公证技术的有：字节雪球的witness、ZCASH的6参数生成过程，rootstacke中的semi-trust-free-sidechains（公证方案）。这种方式优点就是简单，整个过程就是对公证节点的信任，缺点就是你需要去信任一或多个实体节点。</p></li></ul><p><strong>侧链/中继（Sidechains/relays）</strong></p><ul><li><p>另一种则是侧链 / 中继（Sidechains/relays），与公证人模式的 “别人告诉 B 链 A 链上发生的事” 不同，中继模式则是更 “直接” 地 B 链自己读 A 链。<br>比如通过验证 A 链区块头和默克尔树等信息验证 A 链上的交易，比如以太坊上的 BTC Relay</p></li><li><p>有些人把这个两个技术分开来说明，这里就放一块解释了。<br>首先有个概念普及下，主链是不知道侧链的存在，侧链则知道主链的存在（其实这个是废话，不知道他怎么做侧链），<br>侧链的概念就是一个链能去读懂另外一个链，用白皮书的定义：sidechain is a blockchain that validates data from other blockchains。</p></li><li><p>侧链存在的条件，一般来说主链通常支持SPV（参考笔者前文比特币架构），主链向侧链提供SPV proof来验证主链中发生的事件（这个事件理解为区块的产生，交易的生成等一系列主链状态的变化）。<br>侧链其实是以锚定比特币为基础的新型区块链，以融合的方式实现加密货币金融生态的目标，而不是像其它加密货币一样排斥现有的系统。</p></li><li><p>中继技术，在A.B两个链中，存在第三方数据结构C，那么这个C就是A和B的中继，如果C也是区块链结构，那么就称relay-chain。<br>举个例子：著名的比特币侧链BTC Relay，一种基于以太坊的智能合约，将以太坊和比特币网络以一种安全去中心化的方式连接起来。</p></li></ul><p><strong>哈希锁定（Hash-locking）</strong></p><ul><li>哈希锁定，也叫原子互换（Atomic Swap），主要是通过哈希时间锁（hash time lock）和密数（Secret）让双方完成交易，不需要第三方公证人。</li></ul><p>互联链</p><h1 id="按共识算法分类"><strong>按共识算法分类</strong><a class="post-anchor" href="#按共识算法分类"></a></h1><p>见共识算法</p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;以下为-mindmanager-的预览&quot;&gt;以下为 mindmanager 的预览&lt;a class=&quot;post-anchor&quot; href=&quot;#以下为-mindmanager-的预览&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;!-- TO
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="导图" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/%E5%AF%BC%E5%9B%BE/"/>
    
    
      <category term="区块链" scheme="http://takostar.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>IPFS简单教程</title>
    <link href="http://takostar.net/2022/01291902/"/>
    <id>http://takostar.net/2022/01291902/</id>
    <published>2022-01-29T11:02:59.000Z</published>
    <updated>2022-01-29T11:11:20.075Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="安装">安装<a class="post-anchor" href="#安装"></a></h2><ul><li><p><a href="https://docs.ipfs.io/install/ipfs-desktop/#install-instructions" target="_blank" rel="noopener">桌面版</a></p></li><li><p><a href="https://dist.ipfs.io/#go-ipfs" target="_blank" rel="noopener">命令行</a></p></li></ul><h3 id="命令行安装">命令行安装<a class="post-anchor" href="#命令行安装"></a></h3><p><a href="https://docs.ipfs.io/install/command-line/#linux" target="_blank" rel="noopener">https://docs.ipfs.io/install/command-line/#linux</a></p><h3 id="命令行初始化">命令行初始化<a class="post-anchor" href="#命令行初始化"></a></h3><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 以64bit为例(先参见上述安装命令进行安装)</span><br><br><span class="hljs-comment"># 在~目录下创建结点.ipfs目录</span><br>ipfs init<br><span class="hljs-comment"># 开启服务守护进程</span><br>ipfs daemon<br></code></pre></td></tr></tbody></table></figure><h2 id="网关">网关<a class="post-anchor" href="#网关"></a></h2><h3 id="WebUI">WebUI<a class="post-anchor" href="#WebUI"></a></h3><p><a href="http://127.0.0.1:5001/webui" target="_blank" rel="noopener">http://127.0.0.1:5001/webui</a></p><h3 id="Gateway-网关">Gateway 网关<a class="post-anchor" href="#Gateway-网关"></a></h3><p><a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a></p><h3 id="HTTP-API">HTTP API<a class="post-anchor" href="#HTTP-API"></a></h3><p><a href="http://127.0.0.1:5001" target="_blank" rel="noopener">http://127.0.0.1:5001</a></p><h3 id="向外网开放-WebUI，Gateway-或-HTTP-API">向外网开放 WebUI，Gateway 或 HTTP API<a class="post-anchor" href="#向外网开放-WebUI，Gateway-或-HTTP-API"></a></h3><ul><li>更改设置，将目标项的地址由 <strong>127.0.0.1</strong> 更改为 <strong>0.0.0.0</strong></li><li>开放 WebUI 和 HTTP API，更改<strong>API</strong></li><li>开放网关，更改<strong>Gateway</strong><blockquote><ul><li>通过图形界面<br><a href="images/desktop-config.png" data-caption="通过图形界面" data-fancybox="images"><img src="images/desktop-config.png" alt="通过图形界面"></a></li><li>对于命令行，更改用户目录下~/.ipfs/config，或运行</li></ul><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> EDITOR=/usr/bin/vim<br>ipfs config edit<br></code></pre></td></tr></tbody></table></figure></blockquote></li></ul><h2 id="文件添加">文件添加<a class="post-anchor" href="#文件添加"></a></h2><h3 id="命令行">命令行<a class="post-anchor" href="#命令行"></a></h3><figure class="highlight sh"><table><tbody><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">"test command line"</span> &gt; command.txt<br>ipfs add command.txt<br><span class="hljs-comment"># 返回 added QmXWrM5PCU1jcZ6xBoLxZ2uXxuWmBRdoJcoe9pNP4yGBKa command.txt</span><br>ipfs cat QmXWrM5PCU1jcZ6xBoLxZ2uXxuWmBRdoJcoe9pNP4yGBKa<br><span class="hljs-comment"># 返回 test command line</span><br></code></pre></td></tr></tbody></table></figure><h3 id="POSTMAN">POSTMAN<a class="post-anchor" href="#POSTMAN"></a></h3><ol><li><p>在<strong>C:\Users\&lt;你的用户名&gt;\Postman\files</strong>下创建<strong>postman.txt</strong>，写入 test postman</p></li><li><p>在表单中选择 postman 文件目录下的文件，参数设为 file</p></li><li><p>点击<strong>Send</strong></p></li></ol><p><a href="images/postman.png" data-caption="postman" data-fancybox="images"><img src="images/postman.png" alt="postman"></a></p><h3 id="JAVA-demo">JAVA demo<a class="post-anchor" href="#JAVA-demo"></a></h3><p><a href="ipfs-demo/src/main/java/com/hncfx/api/ADD.java">以 okhttp 为例</a></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><code class="hljs java">RequestBody body = <span class="hljs-keyword">new</span> MultipartBody.Builder().setType(MultipartBody.FORM)<br>                <span class="hljs-comment">// 使用file为表单键上传文件</span><br>                .addFormDataPart(<span class="hljs-string">"file"</span>, file.getName(), filebody)<br>                .build();<br>Request request = <span class="hljs-keyword">new</span> Request.Builder()<br>                .url(<span class="hljs-string">"http://127.0.0.1:5001/api/v0/add"</span>)<br>                .method(<span class="hljs-string">"POST"</span>, body)<br>                .build();<br>Response response = client.newCall(request).execute();<br></code></pre></td></tr></tbody></table></figure><h2 id="文件查看">文件查看<a class="post-anchor" href="#文件查看"></a></h2><ul><li>desktop 上通过 qmhash 查看<br><a href="images/desktop-view.png" data-caption="qmhash" data-fancybox="images"><img src="images/desktop-view.png" alt="qmhash"></a></li><li><a href="https://ipfs.io/ipfs/QmQ9t2hmjjfBgDYvvTmBu2aDt6ZeVWDKLnMtP3ic6RWSDz" target="_blank" rel="noopener">通过网关访问</a><blockquote><p><a href="https://ipfs.github.io/public-gateway-checker/" target="_blank" rel="noopener">公共网关</a></p></blockquote></li></ul><h2 id="常用命令">常用命令<a class="post-anchor" href="#常用命令"></a></h2><ul><li><p><strong>ipfs add</strong> 添加文件</p></li><li><p><strong>ipfs cat</strong> 打印文件</p></li><li><p><strong>ipfs config show</strong> 显示设置</p></li><li><p><strong>ipfs pin ls</strong> 显示本地持久化文档(通过 add 添加的默认为本地持久化的)</p></li></ul><h2 id="参考">参考<a class="post-anchor" href="#参考"></a></h2><p><a href="https://www.jianshu.com/p/48a2739bade2" target="_blank" rel="noopener">IPFS 开发简介与入门实战 - 简书</a></p><p><a href="https://github.com/miaoski/ipfs-tutorial" target="_blank" rel="noopener">miaoski/ipfs-tutorial: IPFS 筆記和教學 (繁體中文)</a></p><p><a href="https://docs.ipfs.io/" target="_blank" rel="noopener">IPFS Documentation | IPFS Docs</a></p><p><a href="http://cw.hubwiz.com/card/c/ipfs/1/1/1/" target="_blank" rel="noopener">ipfs命令手册</a></p></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;安装&quot;&gt;安装&lt;a class=&quot;post-anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://docs.ipfs.io/install/ipfs-des
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="区块链" scheme="http://takostar.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Git的一般使用流程图</title>
    <link href="http://takostar.net/2020/03302317/"/>
    <id>http://takostar.net/2020/03302317/</id>
    <published>2020-03-30T15:17:38.000Z</published>
    <updated>2022-02-12T11:28:54.850Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="以下为-mindmanager-的预览">以下为 mindmanager 的预览<a class="post-anchor" href="#以下为-mindmanager-的预览"></a></h2><!-- TODO:实现搜索框的按键展示(使用页面缩放?或者是弹性相应和直接style) --><div class="post-mindmap">  <iframe class="mindmap" id="mindmap" src="git的一般使用流程图.html"></iframe>  <div class="r">  <span class="iconfont icon-close"></span>    <div class="tip"></div>    <a class="fullscreen-button">Full Screen</a></div></div>  <script type="text/javascript">    var sonWidth = document.getElementById("mindmap").offsetWidth;    document.getElementById("mindmap").style.height = sonWidth * 0.7 + "px";</script><!-- * @Author: tako star * @Date: 2020-03-30 23:17:38 * @LastEditors: tako star * @LastEditTime: 2020-04-16 16:51:03 --></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;以下为-mindmanager-的预览&quot;&gt;以下为 mindmanager 的预览&lt;a class=&quot;post-anchor&quot; href=&quot;#以下为-mindmanager-的预览&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;!-- TO
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="导图" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/%E5%AF%BC%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Github仓库搜索技巧介绍</title>
    <link href="http://takostar.net/2020/02041547/"/>
    <id>http://takostar.net/2020/02041547/</id>
    <published>2020-02-04T07:47:04.000Z</published>
    <updated>2022-01-29T09:25:09.986Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="搜索关键词">搜索关键词<a class="post-anchor" href="#搜索关键词"></a></h2><h3 id="in-name-keyword">in:name keyword<a class="post-anchor" href="#in-name-keyword"></a></h3><blockquote><p>如 <code>in:name spring boot</code></p></blockquote><ul><li>用上述方法可以迅速的找到自己想要的 github 项目<br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/mindmap.png" data-caption="在项目描述中寻找关键词" 思维导图".png"="" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/mindmap.png" alt="在项目描述中寻找关键词" 思维导图".png"=""></a><br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/note.png" data-caption="迅速寻找笔记.png" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/note.png" alt="迅速寻找笔记.png"></a></li></ul><h4 id="其他关键词搜索目标">其他关键词搜索目标<a class="post-anchor" href="#其他关键词搜索目标"></a></h4><ul><li>readme</li><li>description</li><li>……</li></ul><h2 id="项目筛选方式">项目筛选方式<a class="post-anchor" href="#项目筛选方式"></a></h2><ul><li>star</li></ul><blockquote><p>如<code>stars:&gt;300</code></p></blockquote><ul><li>language</li></ul><blockquote><p>如<code>language:java</code></p></blockquote><ul><li>fork</li></ul><blockquote><p>如<code>fork:&gt;300</code></p></blockquote><ul><li>pushed</li></ul><blockquote><p>如<code>pushed:&gt;2019-2-3</code></p></blockquote><ul><li>……</li></ul><h2 id="更多搜索技巧和范围">更多搜索技巧和范围<a class="post-anchor" href="#更多搜索技巧和范围"></a></h2><ul><li><p>不同筛选条件用空格间隔并列</p></li><li><p>更加详细的搜索方法可以在<a href="https://help.github.com/cn/github/searching-for-information-on-github/searching-on-github" target="_blank" rel="noopener">github 的官方使用帮助</a>上搜索获取更多种类的搜索方式<br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/doc.png" data-caption="image.png" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/doc.png" alt="image.png"></a></p><p> 如根据帮助文档描述寻找住在北京的 github 用户：</p><blockquote><p><code>location:beijing</code><br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/location.png" data-caption="image.png" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/02041547/location.png" alt="image.png"></a></p></blockquote></li></ul><!-- * @Author: tako star * @Date: 2020-02-04 15:47:05 * @LastEditors: tako star * @LastEditTime: 2020-04-06 19:44:44 --></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;搜索关键词&quot;&gt;搜索关键词&lt;a class=&quot;post-anchor&quot; href=&quot;#搜索关键词&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;in-name-keyword&quot;&gt;in:name keyword&lt;a class=
      
    
    </summary>
    
    
      <category term="笔记" scheme="http://takostar.net/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Github" scheme="http://takostar.net/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>我的博客建立成功！</title>
    <link href="http://takostar.net/2020/01301130/"/>
    <id>http://takostar.net/2020/01301130/</id>
    <published>2020-01-30T03:30:02.000Z</published>
    <updated>2022-01-29T09:25:10.001Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="博客建立成功">博客建立成功<a class="post-anchor" href="#博客建立成功"></a></h2><hr><ul><li>基于 hexo 建立的博客，使用了 github 的托管,其中 hexo 的主题为<a href="https://github.com/shixiaohu2206/hexo-theme-huhu" target="_blank" rel="noopener">hexo-theme-huhu</a></li><li>教程参考于 codesheep 的<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">博客搭建教程</a></li><li>本博客将用于整理分享的学习经验和总结</li></ul><p>​ ——TakoStar</p><h2 id="建立博客的经验">建立博客的经验<a class="post-anchor" href="#建立博客的经验"></a></h2><h3 id="搭建">搭建<a class="post-anchor" href="#搭建"></a></h3><p>codesheep 的<a href="https://www.bilibili.com/video/av44544186" target="_blank" rel="noopener">博客搭建教程</a></p><h3 id="完善">完善<a class="post-anchor" href="#完善"></a></h3><ul><li>评论</li><li>百度统计</li></ul><h3 id="SEO">SEO<a class="post-anchor" href="#SEO"></a></h3><ul><li>域名</li><li>证书</li><li>备案</li><li>百度、谷歌收录</li></ul><h2 id="我对博客的看法">我对博客的看法<a class="post-anchor" href="#我对博客的看法"></a></h2><ol><li>为什么写博客</li><li>如何写博客</li></ol><h2 id="关于我">关于我<a class="post-anchor" href="#关于我"></a></h2><ul><li>男，ACGN 爱好者</li><li>以一个合格的程序员为目标努力中<br><a href="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/01301130/12218320_p0.jpg" data-caption="秋庭里香——仰望半月的夜空.jpg" data-fancybox="images"><img src="https://cdn.jsdelivr.net/gh/takostar/takostar.github.io/2020/01301130/12218320_p0.jpg" alt="秋庭里香——仰望半月的夜空.jpg"></a></li></ul><h2 id="站点记录">站点记录<a class="post-anchor" href="#站点记录"></a></h2><p>本站于 <code class="site_from"></code> 接入百度站点，建站已 <code class="site_date"></code> 天</p><!-- 截止到目前，整站访问次数 <code class="site_pv"></code>、访问人数 <code class="site_uv"></code> --><!-- * @Author: tako star * @Date: 2020-01-30 11:30:02 * @LastEditors: tako star * @LastEditTime: 2020-04-16 15:50:52 --></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;h2 id=&quot;博客建立成功&quot;&gt;博客建立成功&lt;a class=&quot;post-anchor&quot; href=&quot;#博客建立成功&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;基于 hexo 建立的博客，使用了 github 的托管,其中 
      
    
    </summary>
    
    
      <category term="关键活动" scheme="http://takostar.net/categories/%E5%85%B3%E9%94%AE%E6%B4%BB%E5%8A%A8/"/>
    
    
      <category term="梦呓" scheme="http://takostar.net/tags/%E6%A2%A6%E5%91%93/"/>
    
  </entry>
  
</feed>
