{"meta":{"title":"TakoStar's yosora","subtitle":"","description":"","author":"Tako","url":"http://takostar.net","root":"/"},"pages":[{"title":"friends","date":"2020/01/31","updated":"2022/01/29","comments":true,"path":"friends/index.html","permalink":"http://takostar.net/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020/01/31","updated":"2022/01/29","comments":true,"path":"categories/index.html","permalink":"http://takostar.net/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020/01/31","updated":"2022/01/29","comments":true,"path":"tags/index.html","permalink":"http://takostar.net/tags/index.html","excerpt":"","text":""}],"posts":[{"path":"2022/03242234/","updated":"2022/03/24","tags":[{"name":"加密学","slug":"加密学","permalink":"http://takostar.net/tags/%E5%8A%A0%E5%AF%86%E5%AD%A6/"}],"title":"CA,RA等加密学中的常用术语","date":"2022/03/24","text":"以下为 mindmanager 的预览 Full Screen var sonWidth = document.getElementById(\"mindmap\").offsetWidth; document.getElementById(\"mindmap\").style.height = sonWidth * 0.7 + \"px\"; 密码常用术语明文待加密的信息 密文经过加密后的明文 加密明文转为密文的过程 加密算法明文转为密文的转换算法 加密密钥通过加密算法进行加密操作作用的密钥 解密将密文转为明文的过程 解密算法密文转为明文的算法 解密密钥通过解密算法进行解密操作作用的密钥 密码分析截获密文者试图通过分析截获的密文从而推断出原来的明文或密钥的过程 主动攻击攻击者非法入侵密码系统，采用伪造，修改，删除等手段向系统注入假消息进行欺骗。（对密文具有破环作用） 被动攻击对一个保密系统采取截获密文并对其进行分析和攻击。（对密文没有破坏作用） 密码体制由明文空间，密文空间，密钥空间，加密算法和解密算法五部分构成 组成明文空间 密文空间 密钥空间 加密算法 解密算法 密码协议也称安全协议，指以密码学为基础的消息交换通信协议，目的是在网络环境中提供安全的服务 密码系统指用于加密，解密的系统 柯克霍夫原则Kerchoff原则现代密码学设计的基本原则 算法应当公开，但是所有的密钥应当保密 数据的安全基于密钥而不是算法的保密。即系统的安全取决于密钥，对密钥保密，对算法公开。 KMKeypair Management用户密钥管理系统，提供对加密证书密钥进行全过程管理的功能。 PKI定义公钥基础设施（PKI） PKI(Public Key Infrastructure)体系 Public Key Infrastructure公钥基础设施，是提供公钥加密和数字签名服务的系统或平台，目的是为了管理密钥和证书安全并负责验证数字证书持有者身份的一种体系。 是为了能够更有效地运用公钥而制定的一系列规范和规格的总称。公钥基础设施一般根据其英语缩写而简称为PKI。 作用安全地管理和分发证书 PKI 体系核心解决的是证书生命周期相关的认证和管理问题 证书概述数字证书 主要是针对以数字的形式存储的消息进行的处理 包含实体基本资料、公钥和扩展项的数据集 数字证书本质上是个人公钥的认可副本。 数字证书为通信双方提供了保证，保证正在与之通信的人确实具有他们所宣称的身份。 数字证书包含特定的身份标识信息，并且其结构归国际标准X.509决定。 数字证书机制解决非对称加密算法和数字签名中公钥的分发的安全问题 为公钥加上数字签名 公钥证书(Public-Key Certificate,PKC）其实和驾照很相似，里面记有姓名、组织、邮箱地址等个人信息，以及属于此人的公钥，并由认证机构（Certification Authority、CertifyingAuthority,CA)施加数字签名。只要看到公钥证书，我们就可以知道认证机构认定该公钥的确属于此人。公钥证书也简称为证书（certificate） 分类加密数字证书（Encryption Certificate） 用于保护用于加密信息的公钥 签名验证数字证书（Signature Certificate） 保护用于解密签名完成身份验证的公钥 X.509概述 X.509 证书规范 证书遵循的X.509版本。 一般的，一个数字证书内容可能包括基本数据（版本、序列号）、所签名对象信息（签名算法类型、签发者信息、有效期、被签发人、签发的公开密钥）、CA 的数字签名等等。 目前使用最广泛的标准为 ITU 和 ISO 联合制定的 X.509 的 v3 版本规范（RFC 5280），其中定义了如下证书信息域： 版本号（Version Number） 规范的版本号，目前为版本 3，值为 0x2； 序列号（Serial Number） 序列号(来自证书建立者)。 由 CA 维护的为它所颁发的每个证书分配的唯一的序列号，用来追踪和撤销证书。只要拥有签发者信息和序列号，就可以唯一标识一个证书。最大不能超过 20 个字节； 签名算法（Signature Algorithm） 数字签名所采用的算法，如 sha256WithRSAEncryption 或 ecdsa-with-SHA256； 签名算法标识符(指定证书授权机构对证书的内容进行数字签名时使用的技术)。 颁发者（Issuer） 颁发证书单位的标识信息，如 “C=CN, ST=Beijing, L=Beijing, O=org.example.com, CN=ca.org.example.com”； 发布者姓名(发布证书的证书授权机构的身份标识)。 有效期（Validity） 有效期(指定证书有效的日期和时间:开始的日期、时间，以及结束的日期、时间)。 证书的有效期限，包括起止时间； 主体（Subject） 证书拥有者的标识信息（Distinguished Name），如 “C=CN, ST=Beijing, L=Beijing, CN=person.org.example.com”； 主体的名字(包括区分实体身份的唯一名字或DN，相应实体拥有证书中包含的公钥)。 主体的公钥信息（Subject Public Key Info） 主体的公钥(证书的内容:证书拥有者用于建立安全通信的实际公钥)。 所保护的公钥相关的信息； 公钥算法（Public Key Algorithm）：公钥采用的算法； 主体公钥（Subject Public Key）：公钥的内容； 颁发者唯一号（Issuer Unique Identifier）：代表颁发者的唯一信息，仅 2、3 版本支持，可选； 主体唯一号（Subject Unique Identifier）：代表拥有证书实体的唯一信息，仅 2、3 版本支持，可选； 扩展（Extensions，可选）：可选的一些扩展。v3 中可能包括： Subject Key Identifier：实体的密钥标识符，区分实体的多对密钥； Basic Constraints：一般指明是否属于 CA； Authority Key Identifier：颁发这个证书的颁发者的公钥标识符； CRL Distribution Points：撤销文件的发布地址； Key Usage: 证书的用途或功能信息。 此外，证书的颁发者还需要对证书内容利用自己的私钥进行签名，以防止他人篡改证书内容。 其他 …… …… …… …… …… 证书格式PEM X.509 规范中一般推荐使用 PEM（Privacy Enhanced Mail）格式来存储证书相关的文件 X.509 规范中一般推荐使用 PEM（Privacy Enhanced Mail）格式来存储证书相关的文件。证书文件的文件名后缀一般为 .crt 或 .cer，对应私钥文件的文件名后缀一般为 .key，证书请求文件的文件名后缀为 .csr。有时候也统一用 .pem 作为文件名后缀。 PEM 格式采用文本方式进行存储，一般包括首尾标记和内容块，内容块采用 base64 编码。 DER DER（Distinguished Encoding Rules）格式，是采用二进制对证书进行保存，可以与 PEM 格式互相转换。 查看工具 openssl 工具 证书信任链证书中记录了大量信息，其中最重要的包括 签发的公开密钥 和 CA 数字签名 两个信息。因此，只要使用 CA 的公钥再次对这个证书进行签名比对，就能证明某个实体的公钥是否是合法的。 证书授权机构证书授权机构(CA)将公钥基础设施绑定在一起，为数字证书提供公证服务。 任何组织都可以开展CA性质的业务。 注册授权机构(RA)在数字证书发布之前帮助CA验证用户的身份。 证书的生成与撤销注册当希望获得一个数字证书时，你必须首先采用某种方式向证书授权机构证明身份， 这个过程被称为注册。 一旦证书授权机构对你的身份表示满意，你就可以向其提供你的公钥。 CA接着建立一个包合你的身份识别信息和公钥副本的X.509数字证书。 CA随后使用其私钥对证书进行数字化签名，并且向你提供己签名数字证书的副本。 你可以安全地将这个证书分发给希望与之进行安全通信的人。 验证使用CA的公钥检查CA的数字签名来验证这个证书。 信任的前提 CA的数字签名是可信的。 你信任CA。 证书没有被列在CRL(Certificate Revocation List证书撤销列表)中。 证书实际上包含你信任的数据。 购买证书时，应该选择一个被广泛信任的CA。 撤销撤销的理由 证书遭到破坏(例如，证书所有者不慎丢失了私钥)。 证书被错误地发放(例如，CA错误地发放了一个没有进行正确验证的证书)。 证书的细节发生变化(例如，主体的名字发生了变化)。 安全性关联发生变化(例如，担保这份证书的组织机构不再雇用主体)。 证书撤消列表 证书撤销列表(Certificate Revocation List，CRL) 证书被撤消和通知最终用户证书撤消之间存在一段时间延迟。 联机证书状态协议 联机证书状态协议(Online Certificate Status Protocol，OCSP) 消除了认证撤消列表所带来的固有延迟。 非对称密钥的管理目的维护安全性 明智地选择加密系统隐藏式安全不可取，选择算法公开的加密系统。 选择合适的密钥选择密钥长度时应当考虑安全需求与性能之间的平衡。 保证私钥的机密性偶尔允许某人访问私钥，会持久地危害使用该密钥加密的所有通信。 密钥强制轮换 备份密钥 组成要素用户使用PKI的人 认证机构CA颁发证书的人 仓库保存证书的数据库 四个关键要素数字证书 公钥和私钥 证书颁发机构CACA 对用户签发证书实际上是对某个用户公钥，使用 CA 的私钥对其进行签名。 用户证书的签发 由 CA 直接来生成证书（内含公钥）和对应的私钥发给用户 由用户自己生成公钥和私钥，然后由 CA 来对公钥内容进行签名。 CA 对用户签发证书实际上是对某个用户公钥，使用 CA 的私钥对其进行签名。这样任何人都可以用 CA 的公钥对该证书进行合法性验证。验证成功则认可该证书中所提供的用户公钥内容，实现用户公钥的安全分发。 用户证书的签发可以有两种方式。 一般可以由 CA 直接来生成证书（内含公钥）和对应的私钥发给用户； 也可以由用户自己生成公钥和私钥，然后由 CA 来对公钥内容进行签名。 后者情况下，用户一般会首先自行生成一个私钥和证书申请文件（Certificate Signing Request，即 csr 文件），该文件中包括了用户对应的公钥和一些基本信息，如通用名（common name，即 cn）、组织信息、地理位置等。CA 只需要对证书请求文件进行签名，生成证书文件，颁发给用户即可。整个过程中，用户可以保持私钥信息的私密性，不会被其他方获知（包括 CA 方）。 生成证书申请文件的过程并不复杂，用户可以很容易地使用开源软件 openssl 来生成 csr 文件和对应的私钥文件。 证书撤销列表证书超出有效期后会作废，用户也可以主动向 CA 申请撤销某证书文件。 由于 CA 无法强制收回已经颁发出去的数字证书，因此为了实现证书的作废，往往还需要维护一个撤销证书列表（Certificate Revocation List，CRL），用于记录已经撤销的证书序号。 因此，通常情况下，当第三方对某个证书进行验证时，需要首先检查该证书是否在撤销列表中。如果存在，则该证书无法通过验证。如果不在，则继续进行后续的证书验证过程。 核心组件CA（Certification Authority）负责证书的颁发和吊销（Revoke），接收来自 RA 的请求，是最核心的部分 CA 是最核心的组件，主要完成对证书信息的维护 RA（Registration Authority）对用户身份进行验证，校验数据合法性，负责登记，审核过了就发给 CA 证书数据库存放证书，多采用 X.500 系列标准格式。可以配合LDAP 目录服务管理用户信息 操作流程用户通过 RA 登记申请证书，提供身份和认证信息等； CA 审核后完成证书的制造，颁发给用户。 用户如果需要撤销证书则需要再次向 CA 发出申请。 CA证书签发机构CA Certificate Authority证书管理系统，也称认证中心，具备有限的政策制定功能，担任具体的用户公钥证书的签发、生成和发布及CRL生成及发布职能。 一般情况下，证书需要由证书认证机构（Certification Authority，CA）来进行签发和背书 RARegister Authority 用户注册系统，负责管理用户信息，执行用户与证书相关的操作。 SSLSecurity Socket Layer 安全套接层协议，由Netscape（网景）公司开发，是一种因特网上最普遍使用的安全通讯协议，保障网站服务器及浏览器之间的数据传输的安全性。 SSL(Secure Socket Layer )或者 TLS(Transport Layer Security) SSL…… …… 要对通信对象进行认证，可以使用对公钥加上数字签名所生成的证书 …… …… PIN加密模块的口令，当用户使用该加密模块时，需要输入PIN，以防他人使用。 密钥介绍Cryptographic Keys 算法公开，密钥隐匿。现代密码系统不依赖保密的算法，而是依赖于具体的用户或者用户组专用的一个或者多个密钥 密钥长度越长，就越难破解加密系统。现代密码学系统使用至少128位的密钥对数据进行保护，密钥的长度越长，就越难破解加密系统 分类私钥在公共密码系统中，用户的密钥对中只有用户本身才能持有的密钥。 公钥在公共密码系统中，用户的密钥对中可以被其他用户所持有的密钥。 数字签名概述数字签名，常用于身份验证，如数字证书中的身份验证功能即是通过数字签名来完成 签名认证是对非对称加密技术与数字摘要技术的综合运用，指的是将通信内容的摘要信息使用发送者的私钥进行加密，然后将密文与原文一直传输给信息的接收者，接收者通过发送者的公钥解密被解密的摘要信息，然后使用发送者相同的方式产生接要串，与解密的摘要串进行对比，如果相同，则说明接收到的内容是完整的，在传输过程中没有受到第三方篡改，否则说明通信内容已被第三方修改。 数字签名算法可以看做是一种带有密钥的消息摘要算法，并且这种密钥包含了公钥和私钥。也就是说，数字签名算法是非对称加密算法和消息摘要的结合体。 数字签名是利用了“没有私钥的人事实上无法生成使用该私钥所生成的密文”这一性质来实现的。这里所生成的密文并非被用于保证机密性，而是被用于代表一种只有持有该密钥的人才能够生成的信息 这样的信息一般称为认证符号(authenticator),消息认证码也是认证符号的一种，数字签名也是一样。数字签名是通过使用私钥进行加密来产生认证符号的。 主要是针对以数字形式存储消息进行的处理产生一种带有操作者身份信息的编码 区别于不同的摘要的算法，不同的非对称加密方式，数字签名算法也不尽相同。常见的数字签名算法包括MD5withRSA、SHA1withRSA 、MD2withRSA、SHA384withRSA、SHA512withRSA 使用Java Signature API 签名方式直接对消息内容签名实际中用得少，因为消息内容通常很长，而公钥密码加密解密过程耗时比较长。 对消息哈希值进行签名实际中用的多，因为消息哈希值通常比消息短很多 数字签名的生成…… 数字签名的检验…… 应用实例安全信息公告对消息明文哈希进行签名，因为是公告，所以消息没必要加密，直接明文展示。 软件下载 公钥证书 SSL/TSL 实现方式RSA过程 …… …… …… …… …… 实践 DSA只能用于数字签名 ECDSA Rabin ElGamal 攻击中间人攻击双方确认公钥哈希值，如通过打电话 对单向哈希函数的攻击 利用数字签名攻击公钥密码签名操作实际上是在对消息进行解密 防止攻击1：不对消息明文签名，只对消息哈希值签名 防止攻击2：公钥加密和数字签名使用两套不同的密钥对 潜在伪造 其他攻击 数字签名无法解决的问题用于验证签名的公钥的合法性解决办法： 公钥基础设施PKI ………… …… 消息验证码消息认证码(message authentication code)是一种确认完整性并进行认证的技术，取三个单词的首字母，简称为MAC 消息认证码的输入包括任意长度的消息和一个发送者与接收者之间共享的密钥，它可以输出固定长度的数据，这个数据称为MAC值 …… …… 消息认证码解决的问题判断消息是否被篡改消息完整性（一致性） 判断是否有人伪装成发送者发送了该消息消息的认证 消息来自正确的发送者 是一种与密钥相关联的单向哈希函数 应用场景SWIFT IPsec SSL/TSL 实现方式单向哈希函数HMAC 分组密码 流密码 公钥密码 重放攻击解决方案使用递增序号 使用时间戳 使用UUID 无法解决的问题对第三方证明消息来源原因 通信双方都拥有共享密钥，无法确认消息一定是其中一个人发送的 防止否认原因 通信双方都拥有共享密钥，任何一方完全可以否认自己向对方发送过某条消息 认证加密Encrypt-then-MAC先用共享密钥对明文消息进行加密，再对密文进行认证 Encrypt-and-MAC先用共享密钥对明文消息进行加密，再对明文进行认证 MAC-then-Encrypt先对明文进行MAC值计算，再对明文和MAC进行加密 PBE概述基于口令的密码 顾名思义，基于口令的密码(Password Based Encryption,PBE)就是一种根据口令生成密钥并用该密钥进行加密的方法。其中加密和解密使用同一个密钥。 ………… 盐的作用盐是由伪随机数生成器生成的随机数，在生成密钥(KEK)时会和口令一起被输入单向散列函数。 密钥(KEK)是根据秘密的口令生成的，加盐好像没有什么意义，那么盐到底起什么作用呢？盐是用来防御字典攻击的。字典攻击是一种事先进行计算并准备好候选密钥列表的方法。 我们假设在生成KEK的时候没有加盐。那么主动攻击者Mallory就可以根据字典数据事先生成大量的候选KEK。 PGP………… …… 零知识证明零知识证明（Zero Knowledge Proof），是这样的一个过程，证明者在不向验证者提供任何额外信息的前提下，使验证者相信某个论断是正确的。 例如，Alice 向 Bob 证明自己知道某个数字，在证明过程中 Bob 可以按照某个顺序提出问题（比如数字加上某些随机数后的变换）由 Alice 回答，并通过回答确信 Alice 较大概率确实知道某数字。证明过程中，Bob 除了知道 Alice 确实知道该数字外，自己无法获知或推理出任何额外信息（包括该数字本身），也无法用 Alice 的证明去向别人证明（Alice 如果提前猜测出 Bob 问题的顺序，存在作假的可能性）。 零知识证明的研究始于 1985 年 Shafi Goldwasser 等人的论文《The Knowledge Complexity of Interactive Proof-Systems》，目前一般认为至少要满足三个条件：完整性（Completeness）：真实的证明可以让验证者成功验证； 可靠性（Soundness）：虚假的证明无法让验证者保证通过验证，但允许存在小概率例外； 零知识（Zero-Knowledge）：如果得到证明，无法从证明过程中获知除了所证明信息之外的任何信息。 零知识证明是一个通信概念。正如数字签名和数字证书一样，零知识证明交换特定类型的信息， 但是不传输实际的数据。","permalink":"http://takostar.net/2022/03242234/","photos":[]},{"path":"2022/03192214/","updated":"2022/03/19","tags":[{"name":"分布式","slug":"分布式","permalink":"http://takostar.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"title":"分布式场景下的CAP理论BASE理论和事务中的ACID特性","date":"2022/03/19","text":"以下为 mindmanager 的预览 Full Screen var sonWidth = document.getElementById(\"mindmap\").offsetWidth; document.getElementById(\"mindmap\").style.height = sonWidth * 0.7 + \"px\"; CAP历史「CAP」理论由Eric Brewer在2000年PODC会议上提出 是Eric Brewer在Inktomi期间研发搜索引擎、分布式web缓存时得出的一个猜想 后来Seth Gilbert和Nancy Lynch对其进行了证明 概述版本第一版解释 对于一个分布式计算系统，不可能同时满足一致性、可用性、分区容错性三个设计约束 第二版解释 在一个分布式系统中，当涉及读写操作时，只能保证一致性、可用性、分区容错性三者中的二个，另一个必须被牺牲 二个版本差异点 分布式：连接并共享数据。分布式系统并不一定会互联和共享数据，比如：Memcache 不符合 CAP 理论，Mysql 符合 CAP 关注的是对数据的读写操作，而不是分布式系统的所有功能。比如 ZK 的选举机制就不是 CAP 探讨的对象 三个要素只能实现两点，不能兼顾 一个分布式系统不可能满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个。 CAP理论断言任何基于网络的数据共享系统，最多只能满足数据一致性、可用性、分区容忍性三要素中的两个要素。但是通过显式处理分区情形，系统设计师可以做到优化数据一致性和可用性，进而取得三者之间的平衡。 分布式系统在设计时只能满足两种，无法兼顾三种。一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。 对大型网站，可用性与分区容忍性优先级要高于数据一致性，一般会尽量朝着 A、P 的方向设计，然后通过其它手段保证对于一致性的商务需求。 CAP定理（布鲁尔定理）又被称作布鲁尔定理（Brewer’s theorem） C、A、P三者最多只能满足其中两个，和FLP定理一样，CAP定理也指示了一个不可达的结果（impossibility result） 对于分布式系统工程实践，CAP理论更适合描述：在满足分区容错的前提下，没有算法能同时满足数据一致性和服务可用性。In a network subject to communication failures,it is impossible for any web service to implement an atomic read/write shared memory that guarantees a response to every request. 分布式系统无法同时确保一致性、可用性和分区容忍性，设计中往往需要弱化对某个特性的需求。分布式系统最多只能保证其中的两项特性。例如 网络出现分区时，系统无法同时保证一致性和可用性。 要么，节点因没有得到其他节点的确认而不应答（牺牲可用性）； 要么，节点只能应答非一致的结果（牺牲一致性） 一个分布式系统只能满足 一致性 可用性 分区容错性中的两项分区容错性是分布式系统的基本要求，所有一般在C和A做权衡。 因为如果放弃P只能采用单点部署的方式，这样就放弃了可扩展性，也就无所谓的分布式系统了。 一个分布式系统只能满足 一致性 可用性 分区容错性中的两项分区容错性是分布式系统的基本要求，所有一般在C和A做权衡。因为如果放弃P只能采用单点部署的方式，这样就放弃了可扩展性，也就无所谓的分布式系统了。放弃A，如果发生网络故障或为了保证一致性，那么受到影响的服务需要等待一定时间，这段时间内系统无法对外提供正常的服务。放弃C，实际上是放弃数据的强一致性，而保留数据的最终一致性。（强一致性，是指针对一个数据的更新操作成功后，所有用户都能读取到最新的数据） 关注点互相连接 数据而非系统 涉及读写操作 CAP 是忽略网络延迟的 正常运行情况下，不存在 CP 和 AP 的选择，可以同时满足CA 设计约束一致性Consistency版本 版本一：所有节点同一时刻能看到相同数据 版本二：对某个制定的客户端，保证读操作能够返回最新的写操作结果 这里的一致性指是「 线性一致性 」 C: Consistency 一致性 Consistency（一致性） 数据是否在多个副本之间能否保持一致 任何事物应该都是原子的，所有副本上的状态都是事物成功提交后的结果，并保持强一致 一致性(Consistency) 客户端知道一系列的操作都会同时发生(生效) 所有节点访问同一份最新的数据副本 设置定时器，放弃强一致性，达到最终一致性 任何时候所有的应用程序都能访问得到相同的数据 即所有的节点都能访问同一份最新的数据副本 Consistency 一致性 ACID理论 Consistency 因为在分布式的系统中P一定是要被考虑到的，所以就只剩下 AP和CP两个选项 可用性 Consistency(一致性) 如果系统一个操作返回成功，那么之后的读请求都必须读取到这个数据 如果系统一个操作返回失败，那么之后所有的读操作都不能读取这个数据 对调用者而言数据具有强一致性(strong consistency)。即原子性 atomic、线性一致性 linearizable consistency 可用性Availability要素 （1）有限时间内 （2）返回正常结果 版本 版本一：每个请求都能得到成功或失败的响应 版本二：非故障的节点在合理时间内返回合理的响应（不是错误或尝试的响应） A: Availability 可用性(指的是快速获取数据) 可用性 系统服务一直处于可用状态.(总能在有限时间内返回结果) 保证每个请求不管成功或失败都有响应 可用性(Availability) 每个操作都必须以可预期的响应结束 每次请求都能获取到非错的响应，所有的读和写都必须要能终止 任何时候任何程序都可以读写数据 在集群中一部分节点故障后，集群整体是否还能响应客户的读写请求 即对数据更新具备高可用性 Availability 因为在分布式的系统中P一定是要被考虑到的，所以就只剩下 AP和CP两个选项 可用性（Availability） 系统提供的服务必须一直处于可用状态，对于每一个操作请求总是能够在有限时间（区分场景）内返回结果 所有读写请求在一定时间内响应，可终止、不会一直等待 非故障的节点再合理的时间内返回合理的响应 系统能在有限时间内完成对操作请求的应答 分区容错性Partition tolerance概述 分区容错性(Partition tolerance) P: Tolerance of network Partition 分区容忍性(分布式) 即使出现单个组件无法可用,操作依然可以完成 必须需要实现 遇到某节点或网络分区故障的时候仍然可以提供一致性和可用性的服务 对于分布式系统来说，P是不能放弃的 分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。 要保证分区容错, 就只能在一致性和可用性之间 选择一个,如果选择可用性,则数据会不一致,如果保证数据一致,则不可用. 当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。 提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。 版本 版本一：出现消息丢失或分区错误时系统能够继续运行 版本二：当出现网络分区后，系统能后继续履行职责 网络分区容错性 当系统出现分区,出现多个网络分区,分区间网络不可达, 要保证能访问数据,就一定需要保证数据冗余多副本保存.所以网络分区容错可以理解为数据副本冗余.即使因为网络或者其他原因,某些节点退出,分布式系统也能恢复(要求数据冗余). 即使分布式系统内部不需要互相访问,也要考虑节点挂掉的影响. 分区容错性是一个最基本的要求。因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然出现子网络。而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡 系统可以跨网络分区线性的伸缩和扩展 分区相当于对通信的实现要求，系统如果不能在时限内达成数据的一致性，就意味着发生了分区的情况 Partition Tolerance 分隔容忍 Partition-tolerance 大部分的分布式系统都分布在不同子网络之间，每个子网络就属于一个分区，分区容错指的就是区间的通信有可能失败，那么如果通信失败则就会出现多个分区，所以在分布式的系统中P一定是满足的，除非你的服务只部署在一台机器上面 系统在遇到任何网络分区故障时，仍然能够保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障 在网络分区的情况下，被分隔的节点仍能正常对外服务 当出现网络分区后，系统能够继续”履行职责” 系统中的网络可能发生分区故障，即节点之间的通信无法保障。而网络故障不应该影响到系统正常服务 限制条件 网络本身无法做到100%可靠，所以必须保证分区容忍性 组合(应用)CA放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择 弱化分区容忍性 现实中，网络分区出现概率较小，但很难完全避免。两阶段的提交算法，某些关系型数据库以及 ZooKeeper 主要考虑了这种设计。实践中，网络可以通过双通道等机制增强可靠性，实现高稳定的网络通信。 不能容忍网络错误或节点错误，一旦出现，整个系统拒绝写请求 网络本身无法做到100%可靠，有可能出故障，所以分区时一个必然的现象。 因为系统不知道对面节点是否挂掉还是只是网络问题，唯一安全做法是把自己变成只读 单节点挂了 ,就完蛋了 关注一致性和可用性 需要非常严格的全体一致性协议 2PC(两阶段提交) 3PC(三阶段提交) 此时的可用性的不是指多节点高可用的可用性 CP关注一致性和分区容忍性 大多数一致性协议 Paxos算法 Quorum类的算法 保证大多数节点数据一致，少数节点会在数据未同步到最新版本之前处于不可用状态 放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用 zk是放弃可用性 放弃A，如果发生网络故障或为了保证一致性 那么受到影响的服务需要等待一定时间，这段时间内系统无法对外提供正常的服务。 既保证最新数据返回 取到非最新数据时返回错误 CP 架构 二个节点N1、N2，复制通道中断，数据无法同步到 N2，客户端访问 N2，返回 error，违背了可用性，因此只能选择 CP 弱化可用性 对结果一致性很敏感的应用，例如银行取款机，当系统故障时候会拒绝服务。MongoDB、Redis、MapReduce 等为此设计。 Paxos、Raft 等共识算法，主要处理这种情况。在 Paxos 类算法中，可能存在着无法提供可用结果的情形，同时允许少数节点离线。 AP关注可用性和分区容忍性 不能达成一致性要求，需要给出数据冲突，给出数据冲突就需要维护数据版本 保证都能返回数据，可以多版本 二个节点N1、N2，复制通道中断，数据无法同步到 N2，客户端访问 N2，返回 旧的值，不能满足一致性，因此只能选择AP Dynamo AP 例如很多NoSQL系统就是如此，异步复制，一致性很弱 放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择， 放弃C，实际上是放弃数据的强一致性，而保留数据的最终一致性。 强一致性，是指针对一个数据的更新操作成功后，所有用户都能读取到最新的数据 总结：基于 Paxos 算法构建的分布式系统，属于 CAP 架构哪一种？ Paxos 算法提供最终一致性保证 符合 CP 方案 大部分集群方案都是 AP 方案 弱化一致性。 对结果一致性不敏感的应用，如：静态页面内容、实时性较弱的查询类数据库等。允许一段时间才最终更新成功，期间不保证一致性 实例1.关系型数据库一般选择C（一致性）与A（可用性）。 2.HBase选择了C（一致性）与P（分区可容忍性） 3.Cassandra选择了A（可用性）与P（分区可容忍性） CAP关键细节点关注粒度是数据，而不是整个系统 忽略网络延迟的 正常运行情况下，不存在 CP、AP 的选择，可以同时满足 CA分区发生时选择 CP 或 AP 没有分区时，也要考虑如何保证 CA 放弃并不等于什么都不做，需要为分区恢复后做准备 误区关于P的理解Partition：网络分区，即因网络因素将系统分隔为多个单独的部分 有人说，网络分区的情况发生的概率非常小，是不是不用考虑P，保证CA就好 现实情况是我们面对的是一个不可靠的网络、有一定的概率宕机的设备，这两个因素都会导致Partition，因此分布式系统实现中P是一个必须项，而不是一个可选项。 CAP中P的定义 In order to model partition tolerance, the network will be allowed lose arbitrarily many messages sent from one node to another. 网络允许从一个节点到另一个的任意的多个消息的丢失 分区容忍性意味着通过降低系统的其他属性来开发一个复制策略。 网络分区、网络丢包、节点宕机都符合CAP中P的定义 CA非0/1的选择工程实践中一致性有不同程度，可用性也有不同等级，在保证分区容错性的前提下，放宽约束后可以兼容一致性和可用性，两者不是非此即彼 CAP定理中的一致性指强一致性 强一致性要求多个节点组成的被调用能像单个节点一样允许、操作具备原子性，在数据和时序上都有要求 放宽时间、时序要求 sequential consistency（序列一致性） 不要去时序一致 enventual consistency（最终一致性） 放宽对时间的要求 可用性在CAP定理中指所有读写操作必须要能终止 实际应用中从主调、被调视觉来看，可用性具有不同的含义 当P(网络分区)出现时，主调可以只支持读操作，通过牺牲部分可用性达成数据一致 工程实践中，较常见的做法是通过异步拷贝副本(asynchronous replication)、quorum/NRW，实现在调用端看来数据强一致、被调端最终一致，在调用端看来服务可用、被调端允许部分节点不可用(或被网络分隔)的效果 跳出CAPCAP理论对实现分布式系统具有指导意义，但CAP理论并没有涵盖分布式工程实践中的所有重要因素 延时（latency） 衡量系统可用性、与用户体验直接相关的一项重要指标 加上延时考虑 CAP理论修改版：PACELC 如果出现P(网络分区)，如何在A(服务可用性)、C(数据一致性)之间选择；否则，如何在L(延时)、C(数据一致性)之间选择。 如果要达到强一致性、多个副本数据一致，必然增加延时 CAP理论中的可用性要求操作能终止、不无休止地进行 其他为什么不能都保证 分布式领域CAP理论，Consistency(一致性), 数据一致更新，所有数据变动都是同步的 Availability(可用性), 好的响应性能 Partition tolerance(分区容忍性) 可靠性 定理：任何分布式系统只可同时满足二点，没法三者兼顾。 忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式系统，而是应该进行取舍。 BASE概述BASE 理论是 Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。 完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态 指基本可以、软状态、最终一致性，核心思想是即使无法做到强一致性，但可以采用适合的方式达到最终一致性 BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的 BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性： 约束基本可用（Basically Available）概述 指分布式系统在出现不可预知故障的时候，允许损失部分可用性。 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。 支持分区失败(e.g. sharding碎片划分数据库) 分布式系统再出现故障时，允许损失部分可用性，即保证核心可用 关键字：部分、核心，根据业务选择 在分布式系统出现不可预知的故障时, 允许损失部分可用性 损失 响应时间上的损失 响应时间增长.但不会失败 响应时间上的损失 正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。 功能上的损失 部分功能不可用 系统功能上的损失，网页降级 当流量高峰期时，屏蔽一些功能的使用以保证系统稳定性（服务降级） 正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。 软状态（ Soft State）指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 允许系统存在中间状态，而该中间状态不会影响系统整体可用性 不同节点的数据副本之间进行数据同步的过程存在延时 状态可以有一段时间不同步，异步。 Soft-state –软状态/柔性事务 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的 和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。比如支付过程 最终一致性（ Eventual Consistency）概述 强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性 所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态 允许数据在一段时间内是不一致的，但系统中的所有数据副本在经过一段时间的同步之后，最终能够达到一致的状态 需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性 关键字 一定时间、最终。不同的数据能够容忍的不一致时间是不同的 分类 （1）因果一致性（Causal consistency） 即进程A在更新完数据后通知进程B，那么之后进程B对该项数据的范围都是进程A更新后的最新值。 （2）读己之所写（Read your writes） 进程A更新一项数据后，它自己总是能访问到自己更新过的最新值。 （3）会话一致性（Session consistency） 将数据一致性框定在会话当中，在一个会话当中实现读己之所写的一致性。即执行更新后，客户端在同一个会话中始终能读到该项数据的最新值 （4）单调读一致性（Monotonic read consistency） 如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。 （5）单调写一致性（Monotoic write consistency） 一个系统需要保证来自同一个进程的写操作被顺序执行。 核心思想即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency） BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。 既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。 其他BASE（FROM EBay） 过程 分布式事务转化成多个本地事务 在第一阶段，通过本地的数据库的事务保障，增加了 transaction 表及消息队列 。 在第二阶段，分别读出消息队列（但不删除），通过判断更新记录表 updates_applied 来检测相关记录是否被执行，未被执行的记录会修改 user 表，然后增加一条操作记录到 updates_applied，事务执行成功之后再删除队列。 跨数据库两段提交事务2PC (two-phase commit)， 2PC is the anti-scalability pattern (Pat Helland) 是反可伸缩模式的，JavaEE中的JTA事务可以支持2PC。因为2PC是反模式，尽量不要使用2PC，使用BASE来回避。 BASE模型反ACID模型，完全不同ACID模型，牺牲高一致性，获得可用性或可靠性：Basically Available基本可用。支持分区失败(e.g. sharding碎片划分数据库) Soft state软状态 状态可以有一段时间不同步，异步。 Eventually consistent最终一致，最终数据是一致的就可以了，而不是时时高一致。 实现BASE思想的主要实现有1.按功能划分数据库 2.sharding碎片 BASE思想主要强调基本的可用性，如果你需要高可用性，也就是纯粹的高性能，那么就要以一致性或容忍性为牺牲，BASE思想的方案在性能上还是有潜力可挖的。 现在NOSQL运动丰富了拓展了BASE思想，可按照具体情况定制特别方案，比如忽视一致性，获得高可用性等等，NOSQL应该有下面两个流派：流派 Key-Value存储，如Amaze Dynamo等，可根据CAP三原则灵活选择不同倾向的数据库产品。 领域模型 + 分布式缓存 + 存储 （Qi4j和NoSql运动），可根据CAP三原则结合自己项目定制灵活的分布式方案，难度高。 共同点 都是关系数据库SQL以外的可选方案，逻辑随着数据分布，任何模型都可以自己持久化，将数据处理和数据存储分离，将读和写分离，存储可以是异步或同步，取决于对一致性的要求程度。 不同点 NOSQL之类的Key-Value存储产品是和关系数据库头碰头的产品BOX，可以适合非Java如PHP RUBY等领域，是一种可以拿来就用的产品，而领域模型 + 分布式缓存 + 存储是一种复杂的架构解决方案，不是产品，但这种方式更灵活，更应该是架构师必须掌握的。 色彩红色 蓝色 绿色 CAP和BASE相关点CAP 理论时忽略延时的，而实际应用中延时是无法避免的CP 实际上也是最终一致性，一定时间是几毫米而已 AP 方案中牺牲一致性只是指分区期间，而不是永远放弃一致性分区故障恢复后，系统应达到最终一致性 CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸 ACID事务程序执行单元，里面的操作要么全部执行成功，要么全部执行失败 定义事务的ACID特性 ACID 也是一种比较出名的描述一致性的原则， 通常出现在分布式数据库等基于事务过程的系统中。 以牺牲可用性为代价A即 Atomicity（原子性）。每次事务是原子的，事务包含的所有操作要么全部成功，要么全部不执行。 一旦有操作失败，则需要回退状态到执行事务之前 C即 Consistency（一致性）。数据库的状态在事务执行前后的状态是一致的和完整的，无中间状态。 即只能处于成功事务提交后的状态 I 即 Isolation（隔离性）。各种事务可以并发执行，但彼此之间互相不影响。按照标准 SQL 规范，从弱到强可以分为未授权读取、授权读取、可重复读取和串行化四种隔离等级 D即 Durability（持久性）。 状态的改变是持久的，不会失效。一旦某个事务提交，则它造成的状态变更就是永久性的 关系数据库的ACID模型拥有 高一致性 + 可用性 很难进行分区与之相对应的是BASE（Basic Availability，Soft-state，Eventual Consistency）原则。BASE 原则面向大型高可用分布式系统，主张牺牲掉对强一致性的追求，而实现最终一致性，来换取一定的可用性。 数据库管理系统为了保证事务的正确性而提出来的一个理论 ACID 是数据库事务完整性理论 约束原子性（Atomicity）Atomicity(目标) 事务是最小的执行单位 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 即不可分割，事务要么全部被执行，要么全部不执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生变化；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换。 对一个事务内的操作来说，整个事务是原子的，要么内部的执行（插入或更新）全部成功，要么事务失败，所有操作回滚 事务是一个不可分割的整体，所有操作要么全做，要么全不做；只要事务中有一个操作出错，回滚到事务开始前的状态的话，那么之前已经执行的所有操作都是无效的，都应该回滚到开始前的状态 事务中的操作是原子的，一个事务中的所有操作，要么全部完成，要么全部不完成，不会再中间某个环节结束 事务中各项操作，要么全做要么不做，任何一项操作的失败都会导致整个事务的失败 一个事务必须是一个不可分割的最小工作单元，整个事务的全部操作，要么全部提交成功，要么全部失败回滚，不可能执行其中一部分。 一致性（Consistency）Consistency(约束) 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 事务的执行使得数据库从一种正确状态转换成另外一种正确状态。 不受并发等影响，事务执行成功，则数据是确定的 事务执行前后，数据从一个状态到另一个状态必须是一致的，比如A向B转账（A、B的总金额就是一个一致性状态），不可能出现A扣了钱，B却没收到的情况发生。 再事务开始之前和事务结束以后，数据库的完整性没有被破坏 在事务开始或结束时，数据库应该在一致状态。 数据库事务执行的结果总是从一个一致性的状态转换到另外一个一致性状态。没有中间状态 执行完后，数据保证一致 事务结束后系统状态是一样的 一旦事务完成,系统必须确保所建模业务一致状态 规则一致性 主键约束 唯一键约束 外键约束 逻辑一致性 悲观锁 乐观锁 双重锁检查 balking模式 隔离性（Isolation）概述 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别 事务与事务之间不受影响，中间状态不可见 并发执行的事务彼此无法看到对方的中间状态 防止多个事务并发执行时由于交叉执行而导致数据的不一致 一个事务的执行不能被其它事务干扰 并发执行时，事务不被其他事务所干扰 事务将假定只有它自己在操作数据库，彼此不知晓。 事务之间的隔离级别，对其他事务的可见性。通常一个事务所做的修改在最终提交之前 对其他事务是不可见的。 在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应该显示给其他事务。 事务之间彼此隔离,往往涉及到锁定数据库中行或表 多个并发事务之间相互隔离，不能互相干扰。 关于事务的隔离性，可能不是特别好理解，这里的并发事务是指两个事务操作了同一份数据的情况；而对于并发事务操作同一份数据的隔离性问题，则是要求不能出现脏读、幻读的情况，即事务A不能读取事务B还没有提交的数据，或者在事务A读取数据进行更新操作时，不允许事务B率先更新掉这条数据。而为了解决这个问题，常用的手段就是加锁了，对于数据库来说就是通过数据库的相关锁机制来保证。 事务隔离级别 读未提交（Read uncommitted） Read Uncommitted（读取未提交内容） 读提交（read committed） Read Committed（读取提交内容） 可重复读（repeatable read） Repeatable Read（可重读） 串行化（Serializable） Serializable（可串行化） 问题 脏读 不可重复读 幻读 持久性（Durability）一旦事务正确提交 ，则其所做的修改就会永久保存在数据库中，不能回滚。即使在事务提交之后有了其他故障，即使系统崩溃，事务的处理结果也会得到保存，修改的数据也不会丢失。 一旦事务完成，就不能返回 事务完成后所做的改动都会持久化 Durability(架构) 架构师、DBA","permalink":"http://takostar.net/2022/03192214/","photos":[]},{"path":"2022/02212221/","updated":"2022/02/27","tags":[{"name":"鉴权","slug":"鉴权","permalink":"http://takostar.net/tags/%E9%89%B4%E6%9D%83/"}],"title":"RBAC权限模型 - 基于角色的访问控制","date":"2022/02/21","text":"以下为 mindmanager 的预览 Full Screen var sonWidth = document.getElementById(\"mindmap\").offsetWidth; document.getElementById(\"mindmap\").style.height = sonWidth * 0.7 + \"px\"; RABC概述权限管理模型 RBAC（Role-Based Access Control，基于角色的访问控制），就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。 RBAC是一套成熟的权限模型。在传统权限模型中，我们直接把权限赋予用户。而在RBAC中，增加了“角色”的概念，我们首先把权限赋予角色，再把角色赋予用户。这样，由于增加了角色，授权会更加灵活方便。 在RBAC中，根据权限的复杂程度，又可分为RBAC0、RBAC1、RBAC2、RBAC3。其中，RBAC0是基础，RBAC1、RBAC2、RBAC3都是以RBAC0为基础的升级。我们可以根据自家产品权限的复杂程度，选取适合的权限模型。 RBAC 认为授权实际上是Who 、What 、How 三元组之间的关系，也就是Who 对What 进行How 的操作，也就是“主体”对“客体”的操作。Who：是权限的拥有者或主体（如：User，Role）。 What：是操作或对象（operation，object）。 How：具体的权限（Privilege,正向授权与负向授权）。 组成User用户 Role角色 分类 admin user …… Resource(Permission)权限/资源 分类 功能权限 模块 菜单权限 页内按钮操作 数据级 uri权限 页面，代表前端路由地址 按钮，代表后端接口地址 扩展用户组 菜单 分类基本模型RBAC0介绍 RBAC0是基础，很多产品只需基于RBAC0就可以搭建权限模型了。在这个模型中，我们把权限赋予角色，再把角色赋予用户。用户和角色，角色和权限都是多对多的关系。用户拥有的权限等于他所有的角色持有权限之和。 举例 譬如我们做一款企业管理产品，如果按传统权限模型，给每一个用户赋予权限则会非常麻烦，并且做不到批量修改用户权限。这时候，可以抽象出几个角色，譬如销售经理、财务经理、市场经理等，然后把权限分配给这些角色，再把角色赋予用户。这样无论是分配权限还是以后的修改权限，只需要修改用户和角色的关系，或角色和权限的关系即可，更加灵活方便。此外，如果一个用户有多个角色，譬如王先生既负责销售部也负责市场部，那么可以给王先生赋予两个角色，即销售经理+市场经理，这样他就拥有这两个角色的所有权限。 RBAC0模型图 …… RBAC0适用场景 评价 角色分层模型RBAC1RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念。简单理解就是，给角色可以分成几个等级，每个等级权限不同，从而实现更细粒度的权限管理。 举例 基于之前RBAC0的例子，我们又发现一个公司的销售经理可能是分几个等级的，譬如除了销售经理，还有销售副经理，而销售副经理只有销售经理的部分权限。这时候，我们就可以采用RBAC1的分级模型，把销售经理这个角色分成多个等级，给销售副经理赋予较低的等级即可。 角色限制模型RBAC2RBAC2同样建立在RBAC0基础之上，仅是对用户、角色和权限三者之间增加了一些限制。这些限制可以分成两类，即静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。 静态职责分离SSD(Static Separation of Duty) 动态职责分离DSD(Dynamic Separation of Duty)。 举例 还是基于之前RBAC0的例子，我们又发现有些角色之间是需要互斥的，譬如给一个用户分配了销售经理的角色，就不能给他再赋予财务经理的角色了，否则他即可以录入合同又能自己审核合同；再譬如，有些公司对角色的升级十分看重，一个销售员要想升级到销售经理，必须先升级到销售主管，这时候就要采用先决条件限制了。 统一模型RBAC3RBAC3是RBAC1和RBAC2的合集，所以RBAC3既有角色分层，也包括可以增加各种限制。 RBAC3= RBAC1 + RBAC2 基于RBAC的延展——用户组基于RBAC模型，还可以适当延展，使其更适合我们的产品。譬如增加用户组概念，直接给用户组分配角色，再把用户加入用户组。这样用户除了拥有自身的权限外，还拥有了所属用户组的所有权限。 譬如，我们可以把一个部门看成一个用户组，如销售部，财务部，再给这个部门直接赋予角色，使部门拥有部门权限，这样这个部门的所有用户都有了部门权限。用户组概念可以更方便的给群体用户授权，且不影响用户本来就拥有的角色权限。 实例实体用户表user id …… 其他用户相关信息 角色表role id pid name 角色名称 status 是否禁用 updated_time created_time 权限表permission id name url status 关系用户角色表 UA id uid role_id created_time 权限角色表 PA id role_id per_id created_time 其他ABAC基于属性的权限验证（ABAC: Attribute-Based Access Control） DAC案例文件系统 自主访问控制（DAC: Discretionary Access Control） MAC强制访问控制（MAC: Mandatory Access Control） 案例政府机密文件 要素控制体 权限标识 用户 权限标识 SAMSAM(Security Access Manager) 有赞","permalink":"http://takostar.net/2022/02212221/","photos":[]},{"path":"2022/02122235/","updated":"2022/02/27","tags":[{"name":"区块链","slug":"区块链","permalink":"http://takostar.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"title":"区块链共识算法分类总结","date":"2022/02/12","text":"以下为 mindmanager 的预览 Full Screen var sonWidth = document.getElementById(\"mindmap\").offsetWidth; document.getElementById(\"mindmap\").style.height = sonWidth * 0.7 + \"px\"; 概述介绍数据同步的方法 所谓“共识机制”，是通过特殊节点的投票，在很短的时间内完成对交易的验证和确认； 对一笔交易，如果利益不相干的若干个节点能够达成共识，我们就可以认为全网对此也能够达成共识。再通俗一点来讲，如果中国一名微博大V、美国一名虚拟币玩家、一名非洲留学生和一名欧洲旅行者互不相识，但他们都一致认为你是个好人，那么基本上就可以断定你这人还不坏。 指可以使用所有节点对某一种状态达成一致的方式，有共识机制去中心化才有意义，才具备可信度，否则只是数据共享 目前主流的共识机制有：POW、POS、DPOS、PBFT等 所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。 当加入区块链的节点足够多的时候，基本上不可能伪造出一条不存在的记录，从而杜绝了造假的可能。 区块链的共识机制通常包含了两个方面达成共识的计算机算法，即共识算法（Consensus Algorithm） 达成共识的规则，即共识规则（Consensus Rule） 分布式一致性算法（共识机制）什么是共识， 什么是共识算法？ …… Paxos Raft 所有记账节点之间怎么达成共识，去认定一个记录的有效性，这既是认定的手段，也是防止篡改的手段。区块链提出了四种不同的共识机制，适用于不同的应用场景，在效率和安全性之间取得平衡。 区块链的共识机制具备“少数服从多数”以及“人人平等”的特点，其中：“少数服从多数”并不完全指节点个数，也可以是计算能力、股权数或者其他的计算机可以比较的特征量。 “人人平等”是当节点满足条件时，所有节点都有权优先提出共识结果、直接被其他节点认同后并最后有可能成为最终共识结果。 [8] 以比特币为例，采用的是工作量证明，只有在控制了全网超过51%的记账节点的情况下，才有可能伪造出一条不存在的记录。当加入区块链的节点足够多的时候，这基本上不可能，从而杜绝了造假的可能。 即便在网络通信可靠情况下，一个可扩展的分布式系统的共识问题通用解法的下限是——没有下限（无解） 目的让分布式数据记录不可逆 选择节点产生区块 作用分布式系统对某个提案，大部分节点达成一致意见的过程在区块链系统中没有像银行一样的中心化机构，所以在进行传输信息、价值转移时， 共识机制解决并保证每一笔交易在所有记帐节点上的一致性和正确性问题。 区块链的这种新的共识机制使其在不依靠中心化组织的情况下，依然大规模高效协作完成运转 数据一致性要解决哪些问题 以谁的数据为准 任何结点都可以修改自己所下载的账本，也就是任何一个人都可以伪造账本 在去中心化的网络下，我们只能认为，大多数人认识的数据是对的。只要我控制了一半以上的结点，我让这 “ 大多数人 “ 伪造同一份账本，那么相当于整个账本都被我修改过来了 因为在没有服务器的去中心化的网络下，所谓的真理只不过是大多数人同意的东西。 “ 大多数人 “ 的问题 是人数吗？在网络世界里，我可以用程序模拟出无穷多的 “ 人 “ 出来投票，所以，用人数来解决去中心化的问题，在分不清是人还是狗，是生物还是程序的计算机世界里，是一件很愚蠢的事。 意见分歧问题 如果在同一个时刻，有多个人都在告诉其它人，这账应该这么记 有人说，我转了10块给gg，又有人说，xx转了20块给我 提案，包括：发生顺序、某个键对应的值、谁是主节点…，比较宽泛 多节点系统最关键的是对多个事件的顺序进行共识，即排序 相关概念共识在分布式系统中多个节点之间对某个事情达成一致看法的过程 所有节点对区块的同步 共识机制不同群体所寻求的共同的认识、价值、想法等，在某一方面达成的一致意见。 共识机制就是确定达成某种共识和维护共识的方式 拜占庭将军问题定义 一种分布式场景下的一致性问题 叛徒少于1/3，问题可解 莱斯利·兰波特在其论文[1]中描述了如下问题： 一组拜占庭将军分别各率领一支军队共同围困一座城市。 为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。 因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。 因为各位将军分处城市不同方向，他们只能通过信使互相联系。 在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军， 这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。 系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。 假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。 这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。 这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。 由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。 而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。 因此很难通过保证人员可靠性及通讯可靠性来解决问题。 假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。 在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。 上述的故事映射到计算机系统里，将军便成了计算机，而信差就是通信系统。 虽然上述的问题涉及了电子化的决策支持与信息安全，却没办法单纯的用密码学与数字签名来解决。 因为电路错误仍可能影响整个加密过程，这不是密码学与数字签名算法在解决的问题。 因此计算机就有可能将错误的结果提交去，亦可能导致错误的决策。 拜占庭容错ByzantineFaultTolerance BFT 当失效节点不超过三分之一可达共识 拜占庭容错系统 共识算法 非拜占庭错误的情况 Paxos 基于分布式两阶段提交理论 Raft 容忍拜占庭错误的情况 BFT PBFT POW POS DPOS 错误拜占庭错误 Byzantine Fault Tolerance(BFT) 性能差，容忍不超过1/3的故障节点 PBFT（Practical BFT) 确定性系列算法 不可逆，为最终结果 PoW 概率算法 临时结果，随时间推移或某种强化，被推翻的概率越小 XFT（Cross Fault Tolerance)算法，提升处理速度 Algorand算法，实现更好的性能（1000+TPS） 故障错误 Crash Fault Tolerance(CFT) 性能好，容忍不超过1/2的故障节点 Paxos、Raft及变种算法 评价标准资源消耗 性能效率Pow 低 Pos 较高 DPoS 高 PBFT 高 扩展性对不同加密算法的支持 安全性 特点一致性分布式网络数据的一致性 一个公司内的分布式系统中的结点是被假设成可信任的 而在去中心化的网络下，所有结点要被假设成不可信任的 cap定理 在一致性、可用性和分区容忍性上只能三选两。在区块链的 P2P 网络下也是很类似的，在去中心化、安全和高性能中，我们也只能选两个 所有诚实节点保存的前缀一致 有效性由诚实节点发送的数据会达到其他诚实节点 区块链同步基本流程发送节点将新的数据全网广播 接收节点对数据进行校验，数据记录纳入区块 全网所有接收节点对区块执行共识算法 区块通过共识后，纳入区块链存储。 问题隔离见证交易和结算分开 原因是当前比特币确认时间过长 达到安全的状态需6个区块确认，约1小时 双花双重支付 同一个钱，用两次 理论上说，超过全网51%的算力，就能改账本，完成双花 预防双花 后面查资料看看呗 种类公链工作量证明(Proof of Work，简称POW)定义 工作量证明 可简单理解为一份证明，证明你做过一定量的工作。通过查看工作结果，就能知道你完成了指定量的工作。区块链共识算法用的最多的就是POW。比特币和以太坊都是基于POW的共识机制。 例 比特币在区块的生成过程中使用的就是POW机制， 简单理解就是大家共同争夺记账权利，谁先抢到并正确完成记账工作，谁就得到系统的奖励，奖励为比特币，也就是所谓的“挖矿”。 矿工（参与挖矿的人）通过计算机的算力去完成这个记账工作，这个拥有计算能力的专业计算机就是所谓的“矿机”。 目前有很多数字资产用pow发行新币 开放性和匿名性，意味着任何节点可以随时进入这个网络， 即使是恶意节点。 区块的生成和发送， 意味着对整个区块链状态的修改。 对状态的修改，必须要付出一定的成本， 这里面就是算力， 增大攻击的成本。 …… 在一个不可信的网络环境（节点不可信，网络不可信）下， 如何就状态，在不同的节点之间达成一致 新区块生成条件 …… 要求 10 分钟一个区块， 2016 个区块的时间就是 2 个星期 ( 2016 * 10 * 60 / ( 24 * 60 * 60) = 14 days) 根据时间偏差来对应的调整难度值 调整幅度有最大/最小比例 比喻 谁的算力大，谁就更大的几率做出记账 举例子：比如生成的hash后面几位需要为0.你计算了多少次拿到了这个结果。 评价 特点 1、算一道很难的题，系统给予挖矿奖励 2、多劳多得 优点 1、所有节点均可参与，记账权公平的分派到每个节点，去中心化 2、多劳多得，矿工积极性高 3、安全性高，欺诈成本高，如果能够欺诈成功，那么做诚实节点收益更大 缺点 1、主流矿池垄断严重，存在51%算攻击风险 2、浪费资源严重 3、持币人没有话语权，算力决定一切 4、网络性能低，共识时间长 评价 优点 完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。 只要网络破坏者的算力不超过全网总算力的50%，网络的交易状态就能达成一致，并不可篡改历史记录。 投入越多算力，获得记账权概率越大，越有可能产生新的区块奖励。 缺点 目前比特币挖矿造成大量的算力和能源浪费。 挖矿的激励机制也造成挖矿算力的高度集中 随着算力的集中，渐渐向中心化演变 算力集中于占据了大多数算力矿池 结算周期长，每秒最多结算7笔交易，不适合商业应用。 POW – 农耕文明 需要“工作量证明”来声明新区块 pow：工作量证明，放弃了高性能 挖矿：用大规模的计算来找到一个符合系统要求的区块 ID 要找到符合条件的区块 ID 只能通过暴力穷举的方式，所以要付出大量的系统计算资源和电力。 修改几乎变得不可能 试想，如果生成一个区块需要大量的长时间的计算力。也就是在世界上最好的电脑集群下计算 10 分钟才能打好一个包，那么，当我们要去修改数据内容的时候，这个过程也是一样的。前面说过，如果你要伪造一个块，那么你就要修改后面所有的块，修改一个块的成本如此之高，那么修改整个链的成本也就非常之高了 能掌握 51% 的算力的人也变得几乎不可能 除了伪造一条链的成本很高，还要控制大多数人的算力，这意味着，是一个非常大的金钱的投入。这两个难度加起来，几乎不太可能。 解决分歧 一方面，这么大的工作量找出来的区块 ID，已经有效地降低了大家有意见冲突的概率。另一方面，就算是出现了合法冲突的区块（同时出现了多个合理的区块，即区块链出现分支 / 分叉），也就是多个合法的账本。而因为挖矿的成本太高，导致要同时跟进多个账本是不可能的，所以矿工们只能赌跟其中一个。大多数人所选择的那一个分支的链就会越来越多，于是另外一边也就无人问津，从而作废了。 pow机制存在的问题 越来越中心化地记账 越来越跑不动 工作量证明机制：pow 工作量证明机制即对于工作量的证明，是生成要加入到区块链中的一笔新的交易信息(即新区块)时必须满足的要求。 在基于工作量证明机制构建的区块链网络中，节点通过计算随机哈希散列的数值解争夺记账权，求得正确的数值解以生成区块的能力是节点算力的具体表现。工作量证明机制具有完全去中心化的优点，在以工作量证明机制为共识的区块链中，节点可以自由进出。 大家所熟知的比特币网络就应用工作量证明机制来生产新的货币。然而，由于工作量证明机制在比特币网络中的应用已经吸引了全球计算机大部分的算力，其他想尝试使用该机制的区块链应用很难获得同样规模的算力来维持自身的安全。同时，基于工作量证明机制的挖矿行为还造成了大量的资源浪费，达成共识所需要的周期也较长，因此该机制并不适合商业应用。 工作量证明（POW） 问题 公地悲剧问题 使用项目 比特币、以太坊、比原链等 其他 原理 通过找到合理随机数争夺记账权 权益证明(Proof of Stake，简称POS)定义 通过持有Token（代币）的数量和时长来决定你获得记账的机率，类似于股票的分红制度，持有股权越多的人就能够获得更多的分红。Token相当于区块链系统的权益。 2012年，化名Sunny King的网友推出了Peercoin，该加密电子货币采用工作量证明机制发行新币，采用权益证明机制维护网络安全，这是权益证明机制在加密电子货币中的首次应用。 与要求证明人执行一定量的计算工作不同，权益证明要求证明人提供一定数量加密货币的所有权即可。 权益证明机制的运作方式是： 当创造一个新区块时，矿工需要创建一个“币权”交易，交易会按照预先设定的比例把一些币发送给矿工本身。权益证明机制根据每个节点拥有代币的比例和时间，依据算法等比例地降低节点的挖矿难度，从而加快了寻找随机数的速度。这种共识机制可以缩短达成共识所需的时间，但本质上仍然需要网络中的节点进行挖矿运算。因此，PoS机制并没有从根本上解决PoW机制难以应用于商业领域的问题。 随着代币的集中，渐渐向中心化演变 需要“财产证明”来声明新区块 根据持有数字货币的数量与时间，进行利息发放和区块产生的机制 比喻 谁有的区块链资产多大，谁就更大的几率做记账 资本主义模式，钱越多，责任越多 评价 优点 降低了PoW机制的资源浪费。 加快了运算速度，也可以理解为工作量证明的升级版 缺点 拥有币龄越长的节点获得记账权的几率越大，容易导致马太效应，富者越富，权益会越来越集中,从而失去公正性。 POS – 资本主义 pos：股权证明，放弃了安全 在 PoS 机制下，矿工不在叫矿工，而是叫 Validator（校验者） pow 好像是 “ 多劳多得 “ 的社会，而 pos 更像是 “ 资本主义 “ 社会，钱越多的人越有话语权 pos的好处 不需要那么费劲的挖矿了。那样浪费电力不环保地挖矿的确有点太糟糕了。PoS 很明显地解决了这个问题。 在 PoS 下，你需要有 51% 的财富，你才可以发起攻击，这相对于算力而言需要更多的成本。 设想一下，你得拥有 51% 的比特币，你才能黑了比特币，然而，如果你有 51% 的财富，你为什么要黑了这个系统，自己把自己干死呢？ pos潜在的问题 双重支付的问题 3、POS(股权证明) 特点 1、不挖矿，依靠币龄(币持有数量 * 持有天数)决定记账权，利息即为奖励，记账后币龄清零 2、按钱分配，钱生钱 优点 1、在一定程度上缩短了共识达成的时间 2、节约资源 3、防作弊，币龄越大，获得记账权几率越大、避免51%攻击，会因为攻击会使自己权益受损 缺点 1、数字货币过于集中化，富者越来越富有，散户参与积极性低 项目 ADA等 委托权益证明(Delegated Proof of Stake，简称DPOS)概述 股份授权证明机制 Delegated Proof Of Stake 股份授权证明机制是一种新的保障网络安全的共识机制。它在尝试解决传统的PoW机制和PoS机制问题的同时，还能通过实施科技式的民主抵消中心化所带来的负面效应。 股份授权证明机制与董事会投票类似，该机制拥有一个内置的实时股权人投票系统，就像系统随时都在召开一个永不散场的股东大会，所有股东都在这里投票决定公司决策。基于DPoS机制建立的区块链的去中心化依赖于一定数量的代表，而非全体用户。在这样的区块链中，全体节点投票选举出一定数量的节点代表，由他们来代理全体节点确认区块、维持系统有序运行。同时，区块链中的全体节点具有随时罢免和任命代表的权力。如果必要，全体节点可以通过投票让现任节点代表失去代表资格，重新选举新的代表，实现实时的民主。 股份授权证明机制可以大大缩小参与验证和记账节点的数量，从而达到秒级的共识验证。然而，该共识机制仍然不能完美解决区块链在商业中的应用问题，因为该共识机制无法摆脱对于代币的依赖，而在很多商业应用中并不需要代币的存在。 用户票选代理人。由代理人轮流生成新区块 代理人相互制约，确保不会伪造 类似董事会投票机制 代理权益证明，放弃了去中心化 DPoS 已经开始把区块链的去中心化的初衷开始向中心化的地方演进了 DPoS 就是政治主义社会。谁的选票多谁说话，但是感觉又回到了中心化架构中的 Leader 选举 是基于POS衍生出的更专业的解决方案，类似于董事会投票，指拥有Token的人投票给固定的节点，选举若干代理人，由代理人负责验证和记账。不同于POW和POS的全网都可以参与记账竞争，DPOS的记账节点在一定时间段内是确定的 通过不同的策略，不定时地选中一小群节点，这一小群节点做新区块的创建、验证、签名和相互监督。这样就大幅度减少了区块创建和确认所需要消耗的时间和算力成本。 比喻 每个有币节点投票，产生100名候选人。随机选取一个股东来产生区块。轮流记账 评价 特点 不挖矿 每年按比例增发代币 奖励超级节点 优点 相较pow，dpos大幅提高区块链处理数据的能力，甚至可以实现秒到账，同时也大幅降低维护区块链网络安全的费用 高效、扩展性强 缺点 去中心程度较弱，节点代理是人为选出的，公平性相比POS较低，依赖于代币的增发来维持代理节点的稳定性 21个节点太少，非去中心化，而是多中心化 项目 EOS 其他 DPOS – 社会主义 联盟链实用拜占庭容错算法（Practical Byzantine Fault Tolerance，简称PBFT）概述 Practical Byzantine Fault Tolerance PBFT，是联盟币的共识算法的基础。 实现了在有限个节点的情况下的拜占庭问题，有3f+1的容错性，并同时保证一定的性能。 该算法在保证活性和安全性的前提下提供了（n-1）/3的容错性。主要实现的有拜占庭容错的NFS文件系统。 应用 联盟链和私有链 Hyperledger组织下的Fabric项目使用的是该算法 私链验证池共识机制Pool定义 Pool验证池 Pool验证池基于传统的分布式一致性技术建立，并辅之以数据验证机制，是目前区块链中广泛使用的一种共识机制。 基于传统的分布式一致性技术，加上数据验证机制，是目前行业链大范围在使用的共识机制。 Pool验证池不需要依赖代币就可以工作，在成熟的分布式一致性算法(Pasox、Raft)基础之上，可以实现秒级共识验证，更适合有多方参与的多中心商业模式。不过，Pool验证池也存在一些不足，例如该共识机制能够实现的分布式程度不如PoW机制等。 评价 优点 不需要依赖代币也可以实现秒级共识验证 不需要代币也可以工作，在成熟的分布式一致性算法（Pasox,Raft）基础上实现秒级共识验证。 缺点 去中心化程度弱，更适合多方参与的多中心商业模式 去中心化程度不如bitcoin，适合多中心的商业模式 paxos概述 Paxos算法是莱斯利・兰伯特( Leslie Lamport,现就职于微软研究院)于1990年提出的，是一种基于消息传递的一致性算法。莱斯利・兰伯特于2013年获得了图灵奖。他的分布式计算理论莫定了这门学科的基础。 菜斯利・兰伯特在1978年发表了论文《分布式系统内的时间、时钟事件顺序》(Time, Clocks, and the Ordering of Events in a Distributed System),这篇论文成为目前计算机科学史上被引用最多的文献。他的论文为并发系统的规范与验证课题的研究贡献了核心原理。 Paxos算法是在莱斯利・兰伯特的论文 The Part- Time Parliamen中提出的。在论文中，他以故事的方式讲述了 Paxos算法 古希腊有一个叫 Paxos的岛屿，是爱琴海上的一个小島， Paxos是一个兴盛的商业贸易中心。在这个岛屿上，法律的制定与修订通过议会表决的形式进行，而非传统的神权治。 所有法律都必须经由议会成员授票表决后才能生效实范，而且已通过的律法必须被记录在案。 在岛上，商业繁荣，做生意赚钱才是头等大事，因此没有人愿意始终在议会大斤里从头到尾参与每一个法律表决的会议。为此，每一个议员都来维护一个法律律簿，用来记录一系列已通过的法令，每个法令带有一个唯编号。为了保持各个议员法律律薄内容的一致性，法律律簿是用擦不掉的墨水书写而成的，所以内容一旦书写就不能改变。 在议会中有多个角色的成员：议员和服务员。服务员的工作是在比较曹杂的议会厅里传递信息，议员的工作是发起法律提案或将通过的法律记录在自己的法律律簿上。 由于议员和服务员有可能并不可靠，他们可能随时会因为各种事情临时甚至是彻底离开议会大斤，服务员也有可能重复传递消息，当然也可能有新的议员在临时事务处理完毕后再回到议会大厅进行法律表决，因此议会的协议要求保证在上述情况下能够正确地修订法律并且不会产生冲突。 在法律表决时，议员的角色分为 proposers和 acceptors 通过一个法律决议时，分为两个阶段： 阶段1: prepare阶段 proposer选择一个提案编号n,并将 prepare请求发送给 acceptors群体。 acceptor收到 prepare消息后，如提案的编号大于它已经回复的所有prepare消息，则 acceptor将自己上次接受的提案回复给 proposer,并承诺不再回复小于n的提案；如果提案的编号小于等于它已经回复的所有 prepare消息，则说明是重复消息，不再重复处理。 阶段2:批准阶段 当 proposer收到多数 acceptors对 prepare的回复后，就进入批准阶段。它要向回复 prepare请求的 acceptors发送 accept请求。acceptor收到accept请求后，则立即接受这个请求。 Paxos 问题是指分布式的系统中存在故障（crash fault），但不存在恶意（corrupt）节点的场景（即可能消息丢失或重复，但无错误消息）下的共识达成问题。解决分布式系统中一致性问题的共识算法（Consensus Algorithm），其最基本的功能是为了在多个进程之间对某个值达成一致。通过这个最基本功能，就可以在多个进程之间进行数据库、状态机、账本（区块链）等对象的同步。被广泛应用在 Chubby、ZooKeeper 这样的分布式系统中。类似于两阶段提交算法 基本原理 三个角色 Proposer。提案者，用于提出议案，提案的内容为：令 x=value，对同一轮提案，最多提议一个value Acceptor。投票者，完全对等，在独立的时间轴执行提案投票 Learner。学习者，一个提案超过半数accpetor通过即可被chosen，其他未确定的Acceptor可以通过learner来同步结果 两阶段 Prepare阶段 1.Proposer选择一个提案编号N，向所有的Acceptor广播Prepare(N)请求 2.Acceptor收到Prepare(N)请求，若提案编号N比之前接收的Prepare请求都要大，则承诺(Promise，将N记录下来)将不会接收提案编号比N小的提议，并且带上之前Accept的提议中编号小于N的最大的提案value(没有则为NULL)。如果N比之前接受的提案编号小，则不予理会。 Proposal阶段 1.Proposer收到Acceptor的Promise。 如果未超过半数的Accpetor回复承诺(Promise)则本次提案失败； 如果超过半数的Acceptor回复承诺，又分为不同情况： 如果(回复承诺的)所有Acceptor都未接收过value(都为null)，那么向所有的Acceptor发起(Propose)自己的value和提案编号N。 如果有部分Acceptor接收过value，那么从接受过的value中选择提案编号N最大对应的value作为本次提案的value，提议编号仍然为N(此时Proposer不能提议自己的value，只能信任Acceptor通过的value，以达成收敛的效果) 2.Acceptor接收到Proposal后，如果该提案编号N不等于自身当前承诺的编号(第一阶段记录的)，不接受该请求，相等则将提案的value写入本地 理解 分布式抢占锁 Prepare阶段–申请加锁，Proposal阶段–修改并释放锁 只有超过半数的Acceptor同意，加锁才成功；否则可能存在多个申请加锁的客户端 每个Proposer都可能失效，独占锁机制下获得独占锁定权的Proposer失效会导致死锁 提案编号由Proposer自己维护，一般采用递增机制且全局唯一。这样就可以对提案进行全局排序，只有提案编号高的(最新)的提案被接受，避免了死锁 文章 https://www.jianshu.com/p/ddf0db5d5f52 https://www.chainnode.com/post/220369 raft定义 raft是工程上使用较为广泛的强一致性、去中心化、高可用的分布式协议。在这里强调了是在工程上，因为在学术理论界，最耀眼的还是大名鼎鼎的Paxos。但Paxos是：少数真正理解的人觉得简单，尚未理解的人觉得很难，大多数人都是一知半解。本人也花了很多时间、看了很多材料也没有真正理解。直到看到raft的论文，两位研究者也提到，他们也花了很长的时间来理解Paxos，他们也觉得很难理解，于是研究出了raft算法。 raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下。这些年最为火热的加密货币（比特币、区块链）就需要共识算法，而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），在带着问题学习分布式系统之中心化复制集一文中介绍了中心化复制集的相关知识。raft协议就是一种leader-based的共识算法，与之相应的是leaderless的共识算法。 Raft算法的头号目标就是容易理解（UnderStandable），这从论文的标题就可以看出来。当然，Raft增强了可理解性，在性能、可靠性、可用性方面是不输于Paxos的。 Raft more understandable than Paxos and also provides a better foundation for building practical systems 为了达到易于理解的目标，raft做了很多努力，其中最主要是两件事情： 问题分解 状态简化 问题分解是将”复制集中节点一致性”这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，leader election， log replication，safety，membership changes。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry） Raft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for managing the replicated log.The leader accepts log entries from clients,replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines.A leader can fail or become disconnected from the other servers, in which case a new leader is elected. 上面的引文对raft协议的工作原理进行了高度的概括：raft会先选举出leader，leader完全负责replicated log的管理。leader负责接受所有客户端更新请求，然后复制到follower节点，并在“安全”的时候执行这些请求。如果leader故障，followes会重新选举出新的leader。 Raft 通过远程过程调用(RPC)来实现节点间的通信, 定义了下面几种 RPC: RequestVote RPC: 由 candidate 调用, 用于进行 leader 选举. AppendEntries RPC: 由 leader 调用, 用于复制日志或作为心跳信息(维持leader). 这就涉及到raft最新的两个子问题 leader election 相关概念 term 任期 从上面可以看出，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫term。 …… term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况。 选举过程详解 上面已经说过，如果follower在election timeout内没有收到来自leader的心跳，（也许此时还没有选出leader，大家都在等；也许leader挂了；也许只是leader与该follower之间网络故障），则会主动发起选举。 步骤如下： 增加节点本地的 current term ，切换到candidate状态 投自己一票 并行给其他节点发送 RequestVote RPCs 等待其他节点的回复 在这个过程中，根据来自其他节点的消息，可能出现三种结果 收到majority的投票（含自己的一票），则赢得选举，成为leader 第一种情况，赢得了选举之后，新的leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束： 在任一任期内，单个节点最多只能投一票 候选人知道的信息不能比自己的少（这一部分，后面介绍log replication和safety的时候会详细介绍） first-come-first-served 先来先得 被告知别人已当选，那么自行切换到follower 第二种情况，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。 一段时间内没有收到majority投票，则保持candidate状态，重新发出选举 第三种情况，没有任何节点获得majority投票，比如下图这种情况： …… 总共有四个节点，Node C、Node D同时成为了candidate，进入了term 4，但Node A投了NodeD一票，NodeB投了Node C一票，这就出现了平票 split vote的情况。这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间（没有leader是不能处理客户端写请求的），因此raft引入了randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。 log replication 当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤： 请求完整流程 leader append log entry leader issue AppendEntries RPC in parallel leader wait for majority response leader apply entry to state machine leader reply to client leader notify follower apply log 性质 Election Safety: 最多只有一个节点成为 Leader. Leader Append-Only: Leader 不会删除或覆盖自身的日志, 只会不断将新的日志附加到日志末尾. Log Matching: 如果两条日志(log entry)的term和index相同, 那么从这两条日志开始, 她们和她们前面的所有日志都对应相同. Leader Completeness: 如果一条日志在一个 term 中被 commit 了,那么在该 term 之后的所有 term 中, 这些 term 的 Leader 的日志中都包含这条日志. State Machine Safety: 如果一个节点应用了一条日志到状态机, 那么其他机器不会应用一个 index 与此日志相同, 内容却不同的日志到状态机.也就是说, 对于不同节点应用到状态机的日志, 只要 index 相同, 日志就是相同的. POA定义 POA(Proof of Activity) 行动证明 链上节点相互信任 授权证明（PoA）是PoS一致性算法的子集，主要由测试网和私有或联盟网络使用。在基于PoA的区块链中，交易有效性最终由一组经批准的链上账户确定，称为“授权节点”。确定授权节点的标准是通过网络治理结构中编写的方法确定性地决定的。 PoA被广泛认为是达成共识的最快途径，但依赖于验证节点尚未受到损害的假设。非验证参与者可以像公共以太网那样访问和使用网络（通过利用p2p交易，合约，账户等） PoA共识依赖于验证者的声誉和过去的表现。这个想法是验证者节点将其身份/声誉放到我的身上。私人联盟网络的一个重要方面是链上地址与已知的现实世界身份之间的联系。因此，我们可以说验证节点正在盯着他们的“身份”或“声誉”（而不是他们的经济持有）。这为验证者创建了一定程度的问责制，最适合企业，私有或测试网络。 PoA目前由测试网络Kovan（PoA网络）使用，并且可以在Parity中轻松配置用于私人联盟网络。 Combine Proof of Work component with a Proof of Stake. mining first begins in the traditional manner, with miners vying to be the first to solve a puzzle and claim their reward.The difference is that the blocks being mined do not contain transactions.They are simply templates with header information and the mining reward address.Once this nearly blank block is mined, the system switches to a proof of stake protocol.The header information is used to select a random group of validators to sign the block.These are coin holders (stakeholders) and the larger the stake a validator holds, the greater the chance they will be selected to sign the new block.Once all the chosen validators sign the block it becomes an actual part of the blockchain.If the block remains unsigned by some of the chosen validators after a given time, it is discarded as incomplete and the next winning block is used.Validators are once again chosen and this continues until a winning block is signed by all the chosen validators.The network fees are split between the winning miner and the validators who signed the block. 其他 POA – 共产主义 其他ripple瑞波币 小蚁共识 总结每一种共识机制都不能同时满足安全、效率、公平。 去中心程度越弱，安全性就越低，区块链的速度就越快； 去中心化程度越强，安全性就会越高，区块链的速度就会越慢。 POW完全去中心化，但运行效率太低。 POS提高了效率，但却降低了公平与安全。 DPOS有强烈的中心化特性，却在短期内效率最高。 目前行业区块链大范围使用Pool共识。 其他问题与挑战 如何提出一个待共识的提案？如通过令牌传递、随机选取、权重比较、求解难题… 如何让多个节点对该提案达成共识（同意或拒绝），如投票、规则验证… 故障节点：非拜占庭节点 恶意节点：拜占庭节点 非拜占庭场景的典型例子是通过报数来统计人数，即便偶有冲突（如两人同时报一个数）也能很快解决； 拜占庭场景的一个常见例子是“杀人游戏”，当参与者众多时很难快速达成共识。 共识机制（数据同步）特性少部分写，多读","permalink":"http://takostar.net/2022/02122235/","photos":[]},{"path":"2022/02121133/","updated":"2022/02/27","tags":[{"name":"区块链","slug":"区块链","permalink":"http://takostar.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"title":"区块链的种类","date":"2022/02/12","text":"以下为 mindmanager 的预览 Full Screen var sonWidth = document.getElementById(\"mindmap\").offsetWidth; document.getElementById(\"mindmap\").style.height = sonWidth * 0.7 + \"px\"; 概述…… 按应用范围公有链概念公链（public blockchain） 公有区块链 公有（Public）链 世界上任何个体或者团体都可以发送交易，且交易能够获得该区块链的有效确认，任何人都可以参与其共识过程。 公链，是指全世界任何人都可读取、发送交易且能获得有效确认的共识区块链。公链的安全由工作量证明机制（pow）或权益证明机制(pos)等方式负责维护。 它们是以经济奖励与加密数字验证相结合的方式而存在的，并遵循着一般原则：每个人从中可获得的经济奖励，与对共识过程作出的贡献成正比。 这些区块链通常被认为是“完全去中心化”的 公有区块链是最早的区块链，也是应用最广泛的区块链， 各大bitcoins系列的虚拟数字货币均基于公有区块链，世界上有且仅有一条该币种对应的区块链。 特点所有人可以随时自带的加入和退出，每个节点平等，都有权交易和记账，属于开放式 代表比特币 Bitcoin 以太坊 Ethereum EOS NEO 量子链 比原链 井通链 Hyperledger TRON 联盟链概述联盟（Consortium）链 联合（行业）区块链 共同体区块链 （Consortium blockchains） 由某个群体内部指定多个预选的节点为记账人，每个块的生成由所有的预选节点共同决定（预选节点参与共识过程）， 其他接入节点可以参与交易，但不过问记账过程 (本质上还是托管记账，只是变成分布式记账，预选节点的多少，如何决定每个块的记账者成为该区块链的主要风险点）， 其他任何人可以通过该区块链开放的API进行限定查询； 我们在前面的文章介绍过它。所谓联盟链，就是这个区块链具有准入许可，不像公链，任何人都可以随时进入。准入许可也就意味着候选节点进入区块链时需要得到已经在网络中的节点许可，所以联盟链也叫做许可链。 共同体区块链，是指其共识过程受到预选节点控制的区块链； 例如，有15个金融机构组成一个共同体，每个机构都运行着一个节点，而且为了使每个区块生效需要获得其中10个机构的确认。 区块链或许允许每个人都可读取，或者只受限于参与者，或走混合型的路线， 例如区块的根哈希及其API（应用程序接口）对外公开，API可允许外界用来作有限次数的查询和获取区块链状态的信息。 这些区块链可视为“部分去中心化” 特点仅部分人参与，加入和退出需要授权，选定某些节点为记账人，其他人可以交易，但无记账权，属于半封闭式 代表R3CEV，全球40多个银行成立的联盟组织，2017年7月成立，共享区块链技术 IBM fabric项目 超级账本Fabric Linux基金会发起的超级账本(HyperLedger)项目，2015年成立，fabric是子项目 如银行联盟，搭建转账系统 私有链概述私有（Private）链 私有区块链 私链（private blockchain)，又称无代币区块链（Token-less blockchain） 如果是私有的，有比区块链成本更低的解决方案 完全私有的区块链 , 是指其写入权限仅在一个组织手里的区块链。读取权限或者对外开放，或者被任意程度地进行了限制。相关的应用囊括数据库管理、审计、甚至一个公司，但在很多的情形下，公共的可读性并非是必须的。 关于没有原生代币的系统，是否能被称为区块链，仍然有着很大的争议。一些人认为，没有代币的区块链，可以一种分布式多版本并发控制(MVCC)数据库的形式而存在。多版本并发控制，可防止两笔交易在数据库中修改一个单一列，而区块链，则是阻止两笔交易在区块链中的单个输出（ output）。 特点公司内部使用，可以更好的实现权限控制：管理和审计，属于封闭式 代表如企业内部链 按部署机制主链主网 测试链测试网 按对接类型侧链概述如闪电网络，用于解决比特币区块链确认过久的问题 侧链是一种双向挂钩技术，将主链中的代币锁定到側链中使用。所以可以将主链看作主干道，侧链看作与主链相对独立的一条分支道，作为主链功能的低耦合拓展 如何实现公证人机制（Notary schemes） 第一种是有一组同时承担两条链节点的个人或联盟，也有可能是一条单独的链，告诉 B 链 A 链上发生什么事，或者告诉 B 某个消息的真的。比如 Ripple 开发的跨账本价值传输开放协议 Interledger，但它不是链，只是一套网关协议。V 神把这种称为公证人模式（Notary schemes）。 公证人机制（Notary schemes）：三种方式中最为简单，目前使用的也是比较多的一种方式，举下例子：PBFT协议中，每个节点都是一个公证人，那么你从节点中获得超过三分之二的节点签名，那么就表示这个公证是有效的。或者，在实现锚锭侧链的时候，主链发送交易到侧链时候所拥有的一个多重签名地址，然后需要花费这个交易的时候必须同时提供8-of-10的multisig的签名才是有效。现在使用公证技术的有：字节雪球的witness、ZCASH的6参数生成过程，rootstacke中的semi-trust-free-sidechains（公证方案）。这种方式优点就是简单，整个过程就是对公证节点的信任，缺点就是你需要去信任一或多个实体节点。 侧链/中继（Sidechains/relays） 另一种则是侧链 / 中继（Sidechains/relays），与公证人模式的 “别人告诉 B 链 A 链上发生的事” 不同，中继模式则是更 “直接” 地 B 链自己读 A 链。比如通过验证 A 链区块头和默克尔树等信息验证 A 链上的交易，比如以太坊上的 BTC Relay 有些人把这个两个技术分开来说明，这里就放一块解释了。首先有个概念普及下，主链是不知道侧链的存在，侧链则知道主链的存在（其实这个是废话，不知道他怎么做侧链），侧链的概念就是一个链能去读懂另外一个链，用白皮书的定义：sidechain is a blockchain that validates data from other blockchains。 侧链存在的条件，一般来说主链通常支持SPV（参考笔者前文比特币架构），主链向侧链提供SPV proof来验证主链中发生的事件（这个事件理解为区块的产生，交易的生成等一系列主链状态的变化）。侧链其实是以锚定比特币为基础的新型区块链，以融合的方式实现加密货币金融生态的目标，而不是像其它加密货币一样排斥现有的系统。 中继技术，在A.B两个链中，存在第三方数据结构C，那么这个C就是A和B的中继，如果C也是区块链结构，那么就称relay-chain。举个例子：著名的比特币侧链BTC Relay，一种基于以太坊的智能合约，将以太坊和比特币网络以一种安全去中心化的方式连接起来。 哈希锁定（Hash-locking） 哈希锁定，也叫原子互换（Atomic Swap），主要是通过哈希时间锁（hash time lock）和密数（Secret）让双方完成交易，不需要第三方公证人。 互联链 按共识算法分类见共识算法","permalink":"http://takostar.net/2022/02121133/","photos":[]},{"path":"2022/01291902/","updated":"2022/01/29","tags":[{"name":"区块链","slug":"区块链","permalink":"http://takostar.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}],"title":"IPFS简单教程","date":"2022/01/29","text":"安装 桌面版 命令行 命令行安装https://docs.ipfs.io/install/command-line/#linux 命令行初始化# 以64bit为例(先参见上述安装命令进行安装)# 在~目录下创建结点.ipfs目录ipfs init# 开启服务守护进程ipfs daemon 网关WebUIhttp://127.0.0.1:5001/webui Gateway 网关http://127.0.0.1:8080 HTTP APIhttp://127.0.0.1:5001 向外网开放 WebUI，Gateway 或 HTTP API 更改设置，将目标项的地址由 127.0.0.1 更改为 0.0.0.0 开放 WebUI 和 HTTP API，更改API 开放网关，更改Gateway 通过图形界面 对于命令行，更改用户目录下~/.ipfs/config，或运行 export EDITOR=/usr/bin/vimipfs config edit 文件添加命令行echo \"test command line\" &gt; command.txtipfs add command.txt# 返回 added QmXWrM5PCU1jcZ6xBoLxZ2uXxuWmBRdoJcoe9pNP4yGBKa command.txtipfs cat QmXWrM5PCU1jcZ6xBoLxZ2uXxuWmBRdoJcoe9pNP4yGBKa# 返回 test command line POSTMAN 在C:\\Users\\&lt;你的用户名&gt;\\Postman\\files下创建postman.txt，写入 test postman 在表单中选择 postman 文件目录下的文件，参数设为 file 点击Send JAVA demo以 okhttp 为例 RequestBody body = new MultipartBody.Builder().setType(MultipartBody.FORM) // 使用file为表单键上传文件 .addFormDataPart(\"file\", file.getName(), filebody) .build();Request request = new Request.Builder() .url(\"http://127.0.0.1:5001/api/v0/add\") .method(\"POST\", body) .build();Response response = client.newCall(request).execute(); 文件查看 desktop 上通过 qmhash 查看 通过网关访问 公共网关 常用命令 ipfs add 添加文件 ipfs cat 打印文件 ipfs config show 显示设置 ipfs pin ls 显示本地持久化文档(通过 add 添加的默认为本地持久化的) 参考IPFS 开发简介与入门实战 - 简书 miaoski/ipfs-tutorial: IPFS 筆記和教學 (繁體中文) IPFS Documentation | IPFS Docs ipfs命令手册","permalink":"http://takostar.net/2022/01291902/","photos":[]},{"path":"2020/03302317/","updated":"2022/02/12","tags":[],"title":"Git的一般使用流程图","date":"2020/03/30","text":"以下为 mindmanager 的预览 Full Screen var sonWidth = document.getElementById(\"mindmap\").offsetWidth; document.getElementById(\"mindmap\").style.height = sonWidth * 0.7 + \"px\";","permalink":"http://takostar.net/2020/03302317/","photos":[]},{"path":"2020/02041547/","updated":"2022/01/29","tags":[{"name":"Github","slug":"Github","permalink":"http://takostar.net/tags/Github/"}],"title":"Github仓库搜索技巧介绍","date":"2020/02/04","text":"搜索关键词in:name keyword 如 in:name spring boot 用上述方法可以迅速的找到自己想要的 github 项目 其他关键词搜索目标 readme description …… 项目筛选方式 star 如stars:&gt;300 language 如language:java fork 如fork:&gt;300 pushed 如pushed:&gt;2019-2-3 …… 更多搜索技巧和范围 不同筛选条件用空格间隔并列 更加详细的搜索方法可以在github 的官方使用帮助上搜索获取更多种类的搜索方式 如根据帮助文档描述寻找住在北京的 github 用户： location:beijing","permalink":"http://takostar.net/2020/02041547/","photos":[]},{"path":"2020/01301130/","updated":"2022/01/29","tags":[{"name":"梦呓","slug":"梦呓","permalink":"http://takostar.net/tags/%E6%A2%A6%E5%91%93/"}],"title":"我的博客建立成功！","date":"2020/01/30","text":"博客建立成功 基于 hexo 建立的博客，使用了 github 的托管,其中 hexo 的主题为hexo-theme-huhu 教程参考于 codesheep 的博客搭建教程 本博客将用于整理分享的学习经验和总结 ​ ——TakoStar 建立博客的经验搭建codesheep 的博客搭建教程 完善 评论 百度统计 SEO 域名 证书 备案 百度、谷歌收录 我对博客的看法 为什么写博客 如何写博客 关于我 男，ACGN 爱好者 以一个合格的程序员为目标努力中 站点记录本站于 接入百度站点，建站已 天","permalink":"http://takostar.net/2020/01301130/","photos":["12218320_p0.jpg"]}],"categories":[],"tags":[{"name":"加密学","slug":"加密学","permalink":"http://takostar.net/tags/%E5%8A%A0%E5%AF%86%E5%AD%A6/"},{"name":"分布式","slug":"分布式","permalink":"http://takostar.net/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"鉴权","slug":"鉴权","permalink":"http://takostar.net/tags/%E9%89%B4%E6%9D%83/"},{"name":"区块链","slug":"区块链","permalink":"http://takostar.net/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"Github","slug":"Github","permalink":"http://takostar.net/tags/Github/"},{"name":"梦呓","slug":"梦呓","permalink":"http://takostar.net/tags/%E6%A2%A6%E5%91%93/"}]}